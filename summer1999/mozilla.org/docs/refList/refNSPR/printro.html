<HTML>
<HEAD>
<TITLE>NSPR 2.0: Introduction</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000"
LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000"
MARGINHEIGHT=0 MARGINWIDTH=0>

<MAP NAME="banner">
<AREA SHAPE=RECT COORDS="300,11,558,44" HREF="http://www.mozilla.org/">
</MAP>

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#000000" VALIGN=TOP ROWSPAN=2><IMG
SRC="../../../images/mozilla-banner.gif"
ALT="" BORDER=0 USEMAP="#banner"
WIDTH=600 HEIGHT=58 VSPACE=0 HSPACE=0></TD></TR></TABLE>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="100%">

<TR>


<TD BGCOLOR="#000000" VALIGN=TOP ALIGN=RIGHT><IMG ALT=""
SRC="../../../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>



<TD BGCOLOR="#DDDDDD" VALIGN=TOP><IMG ALT=""
SRC="../../../images/curve1.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD BGCOLOR="#DDDDDD" VALIGN=TOP ALIGN=RIGHT><IMG ALT=""
SRC="../../../images/curve3.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD BGCOLOR="#000000" VALIGN=TOP><IMG ALT=""
SRC="../../../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD VALIGN=TOP><IMG ALT=""
SRC="../../../images/curve1.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD VALIGN=TOP ALIGN=RIGHT>
</TD>


<TD VALIGN=TOP ALIGN=RIGHT><IMG ALT=""
SRC="../../../images/curve3.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD BGCOLOR="#000000" VALIGN=TOP><IMG ALT=""
SRC="../../../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

</TR>


<TR>

<TD BGCOLOR="#000000" VALIGN=TOP ALIGN=RIGHT><IMG ALT=""
SRC="../../../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD BGCOLOR="#DDDDDD" VALIGN=TOP COLSPAN=2>

<TABLE CELLPADDING=0 CELLSPACING=3 BORDER=0>
<TR><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=19><A HREF="../../..//"><B> The Mozilla<BR>Organization</B></A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../mission.html"> Our Mission</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../about.html"> Who We Are</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../get-involved.html"> Getting Involved</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../community.html"> Community</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../advocacy.html"> Editorials</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../news.html"> What's New</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../newsbot/"> Newsbot</A></TD></TR>
<TR><TD NOWRAP VALIGN=TOP COLSPAN=20><B></B></TD></TR>
<TR><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=19><A HREF="../../../development.html"><B> Development</B></A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../roadmap.html"> Roadmap</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../owners.html"> Module Owners</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../blue-sky/"> Blue Sky</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../projects/"> Projects</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../status/"> Status</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../tools.html"> Tools</A></TD></TR>
<TR><TD NOWRAP VALIGN=TOP COLSPAN=20><B></B></TD></TR>
<TR><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=19><A HREF="../../../products.html"><B> Products</B></A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../source.html"> Source Code</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../binaries.html"> Binaries</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../docs/"> Documentation</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../NPL/"> License Terms</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../bugs/"> Bug Reports</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../../../quality/"> Quality</A></TD></TR>
<TR><TD NOWRAP VALIGN=TOP COLSPAN=20><B></B></TD></TR>
<TR><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=19><A HREF="../../../search.html"><B> Search</B></A></TD></TR>
<TR><TD VALIGN=TOP><IMG SRC="../../../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=19><A HREF="../../../feedback.html"><B> Feedback</B></A></TD></TR>
</TABLE>
</TD>


<TD BGCOLOR="#000000" VALIGN=TOP ALIGN=RIGHT><IMG ALT=""
SRC="../../../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD VALIGN=TOP ALIGN=RIGHT>
</TD>


<TD VALIGN=TOP>







<A HREF="contents.html">[Contents]</A> <A HREF="contents.html">[Previous]</A> <A HREF="prtyp.html">[Next]</A> <A HREF="last.html">[Last]</A>
<HR>
<A NAME="1003024">
<P></A><CENTER><H2>Chapter 1<BR><A NAME="1015494">
Introduction to NSPR</H2>
</A></CENTER>
<A NAME="1039908">
The Netscape Portable Runtime (NSPR) API allows compliant applications to use system facilities such as threads, thread synchronization, I/O, interval timing, atomic operations, and several other low-level services in a platform-independent manner. This chapter introduces key NSPR programming concepts and illustrates them with sample code.<P></A>
<A NAME="1038804">
The current implementation of NSPR allows developers to compile a single source code base on Macintosh (PPC), Win32 (NT 3.51, NT 4.0, WIN'95), and over twenty versions of Unix. <P></A>
<A NAME="1038966">
NSPR does not provide a platform for porting existing code. It must be used from the beginning of a software project.<P></A>
<A NAME="1035918">
<A HREF="printro.html#1039783">NSPR Naming Conventions</A><br><A HREF="printro.html#1035921">NSPR Threads</A><br><A HREF="printro.html#1035718">NSPR Thread Synchronization</A><br><A HREF="printro.html#1039835">NSPR Sample Code</A><P></A>

<A NAME="NSPR Naming Conventions"></A>
<A NAME="1039783">
<H2> NSPR Naming Conventions</H2>
</A>
<A NAME="1039804">
Naming of NSPR types, functions, and macros follows the following conventions:<P></A>
<ul><P>
<A NAME="1039805">
<LI>Types exported by NSPR begin with <CODE>PR</CODE> and are followed by intercap-style declarations, like this:</LI>
</A><A NAME="1039806">
<BLOCKQUOTE><CODE>PRInt</CODE>, <CODE>PRFileDesc</CODE> 
</BLOCKQUOTE></A>

<P>
<A NAME="1039807">
<LI>Function definitions begin with <CODE>PR_</CODE> and are followed by intercap-style declarations, like this:</LI>
</A><A NAME="1039808">
<BLOCKQUOTE><CODE>PR_Read</CODE>, <CODE>PR_JoinThread</CODE> 
</BLOCKQUOTE></A>

<P>
<A NAME="1039967">
<LI>Preprocessor macros begin with the letters <CODE>PR</CODE> and are followed by all uppercase characters separated with the underscore character (<CODE>_</CODE>), like this:</LI>
</A><A NAME="1039968">
<BLOCKQUOTE><CODE>PR_BYTES_PER_SHORT</CODE>, <CODE>PR_EXTERN
</CODE></BLOCKQUOTE></A>

</ul>
<A NAME="NSPR Threads"></A>
<A NAME="1035921">
<H2> NSPR Threads</H2>
</A>
<A NAME="1035615">
NSPR provides an execution environment that promotes the use of lightweight threads. Each thread is an execution entity that is scheduled independently from other threads in the same process. A thread has a limited number of resources that it truly owns. These resources include the thread stack and the CPU register set (including PC). <P></A>
<A NAME="1035616">
To an NSPR client, a thread is represented by a pointer to an opaque structure of type <A HREF="prthrd.html#1015580"><CODE>PRThread</CODE></A>. A thread is created by an explicit client request and remains a valid, independent execution entity until it returns from its root function or the process abnormally terminates. (<CODE>PRThread</CODE> and functions for creating and manipulating threads are described in detail in <A HREF="prthrd.html#1015494">Chapter 3, "Threads."</A>)<P></A>
<A NAME="1035620">
NSPR threads are lightweight in the sense that they are cheaper than full-blown processes, but they are not free. They achieve the cost reduction by relying on their containing process to manage most of the resources that they access. This, and the fact that threads share an address space with other threads in the same process, makes it important to remember that <I>threads are not processes.</I> <P></A>
<A NAME="1035621">
NSPR threads are scheduled in two separate domains:<P></A>
<ul><P>
<A NAME="1035622">
<LI><B>Local threads</B> are scheduled within a process only and are handled entirely by NSPR, either by completely emulating threads on each host operating system (OS) that doesn't support threads, or by using the threading facilities of each host OS that does support threads to emulate a relatively large number of local threads by using a relatively small number of native threads.</LI>
</A><P>
<A NAME="1039925">
<LI><B>Global threads</B> are scheduled by the host OS--not by NSPR--either within a process or across processes on the entire host. Global threads correspond to native threads on the host OS.</LI>
</A></ul><A NAME="1035627">
NSPR threads can also be either user threads or system threads. NSPR provides a function, <A HREF="prinit.html#1019243"><CODE>PR_Cleanup</CODE></A>, that synchronizes process termination. <CODE>PR_Cleanup</CODE> waits for the last user thread to exit before returning, whereas it ignores system threads when determining when a process should exit. This arrangement implies that a system thread should not have volatile data that needs to be safely stored away. <P></A>
<A NAME="1037808">
Priorities for NSPR threads are based loosely on hints provided by the client and sometimes constrained by the underlying operating system. Therefore, priorities are not rigidly defined. For more information, see <A HREF="printro.html#1035635">Thread Scheduling</A>.<P></A>
<A NAME="1035632">
In general, it's preferable to create local user threads with normal priority and let NSPR take care of the details as appropriate for each host OS. It's usually not necessary to create a global thread explicitly unless you are planning to port your code only to platforms that provide threading services with which you are familiar or unless the thread will be executing code that might directly call blocking OS functions.<P></A>
<A NAME="1038309">
Threads can also have "per-thread-data" attached to them. Each thread has a built-in per-thread error number and error string that are updated when NSPR operations fail. It's also possible for NSPR clients to define their own per-thread-data. For details, see <A HREF="prthrd.html#1026179">Controlling Per-Thread Private Data</A>.<P></A>

<A NAME="Head2;"></A>
<A NAME="1035635">
<H3> Thread Scheduling</H3>
</A>

<A NAME="1035636">
NSPR threads are scheduled by priority and can be preempted or interrupted. The sections that follow briefly introduce the NSPR approach to these three aspects of thread scheduling.<P></A>
<A NAME="1035640">
<A HREF="printro.html#1035650">Setting Thread Priorities</A> <br><A HREF="printro.html#1035658">Preempting Threads</A> <br><A HREF="printro.html#1035662">Interrupting Threads</A> <P></A>
<A NAME="1036013">
For reference information on the NSPR API used for thread scheduling, see <A HREF="prthrd.html#1015494">Chapter 3, "Threads."</A><P></A>

<A NAME="Head3;"></A>
<A NAME="1035650">
<H4> Setting Thread Priorities</H4>
</A>

<A NAME="1035651">
The host operating systems supported by NSPR differ widely in the mechanisms they use to support thread priorities. In general, an NSPR thread of higher priority has a statistically better chance of running relative to threads of lower priority. However, because of the multiple strategies to provide execution vehicles for threads on various host platforms, priorities are not a clearly defined abstraction in NSPR. At best they are intended to specify a preference with respect to the amount of CPU time that a higher-priority thread might expect relative to a lower-priority thread. This preference is still subject to resource availability, and must not be used in place of proper synchronization. For more information on thread synchronization, see <A HREF="printro.html#1035718">NSPR Thread Synchronization</A>.<P></A>
<A NAME="1035655">
The issue is further muddied by inconsistent offerings from OS vendors regarding the priority of their kernel-supported threads. NSPR assumes that the priorities of global threads are not manageable, but that the host OS will perform some sort of fair scheduling. It's usually preferable to create local user threads with normal priority and let NSPR and the host take care of the details.<P></A>
<A NAME="1038347">
In some NSPR configurations, there may be an arbitrary (and perhaps large) number of local threads being supported by a more limited number of <B>virtual processors</B> (an internal application of global threads). In such situations, each virtual processor will have some number of local threads associated with it, though exactly which local threads and how many may vary over time. NSPR guarantees that for each virtual processor the highest-priority, scheduled local thread is the one executing. This thread implementation strategy is referred to as the <B>M x N model.</B> <P></A>

<A NAME="Head3;"></A>
<A NAME="1035658">
<H4> Preempting Threads</H4>
</A>

<A NAME="1035659">
Preemption is the act of taking control away from a ready thread at an arbitrary point and giving control to another appropriate thread. It might be viewed as taking the executing thread and adding it to the end of the ready queue for its appropriate priority, then simply running the scheduling algorithm to find the most appropriate thread. The chosen thread may be of higher priority, of the same priority, or even the same thread. It will not be a thread of lower priority. <P></A>
<A NAME="1035660">
Some operating systems cannot be made preemptable (for example, Mac OS and Win 16). This puts them at some risk in supporting arbitrary code, even if the code is interpreted (Java). Other systems are not thread-aware, and their runtime libraries not thread-safe (most versions of Unix). These systems can support local level thread abstractions that can be made preemptable, but run the risk of library corruption (<CODE>libc</CODE>). Still other operating systems have a native notion of threads, and their libraries are thread-aware and support locking. However, if local threads are also present, and they are preemptable, they are subject to deadlock. At this time, the only safe solutions are to turn off preemption (a runtime decision) or to preempt global threads only. <P></A>

<A NAME="Head3;"></A>
<A NAME="1035662">
<H4> Interrupting Threads</H4>
</A>

<A NAME="1035663">
NSPR threads are interruptible, with some constraints and inconsistencies. <P></A>
<A NAME="1035667">
To interrupt a thread, the caller of <A HREF="prthrd.html#1015726">PR_Interrupt</A> must have the NSPR reference to the target thread (<A HREF="prthrd.html#1015580">PRThread</A><CODE>*</CODE>). When the target is interrupted, it is rescheduled from the point at which it was blocked, with a status error indicating that it was interrupted. NSPR recognizes only two areas where a thread may be interrupted: waiting on a condition variable and waiting on I/O. In the latter case, interruption does cancel the I/O operation. In neither case does being interrupted imply the demise of the thread. <P></A>

<A NAME="NSPR Thread Synchronization"></A>
<A NAME="1035718">
<H2> NSPR Thread Synchronization</H2>
</A>
<A NAME="1035694">
Thread synchronization has two aspects: locking and notification. Locking prevents access to some resource, such as a piece of shared data: that is, it enforces mutual exclusion. Notification involves passing synchronization information among cooperating threads. <P></A>
<A NAME="1037827">
In NSPR, a <B>mutual exclusion lock </B>(or <B>mutex</B>) of type <A HREF="prlock.html#1018659"><CODE>PRLock</CODE></A> controls locking, and associated <B>condition variables</B> of type <A HREF="prcvar.html#1019073"><CODE>PRCondVar</CODE></A> communicate changes in state among threads. When a programmer associates a mutex with an arbitrary collection of data, the mutex provides a protective <B>monitor</B> around the data. <P></A>

<A NAME="Head2;"></A>
<A NAME="1035807">
<H3> Locks and Monitors</H3>
</A>

<A NAME="1035699">
In general, a monitor is a conceptual entity composed of a mutex, one or more condition variables, and the monitored data. Monitors in this generic sense should not be confused with the monitor type used in Java programming. In addition to <A HREF="prlock.html#1018659"><CODE>PRLock</CODE></A>, NSPR provides another mutex type, <A HREF="prmon.html#421412"><CODE>PRMonitor</CODE></A>, which is reentrant and can have only one associated condition variable. <CODE>PRMonitor</CODE> is intended for use with Java and reflects the Java approach to thread synchronization. <P></A>
<A NAME="1037843">
To access the data in the monitor, the thread performing the access must hold the mutex, also described as being "in the monitor." Mutual exclusion guarantees that only one thread can be in the monitor at a time and that no thread may observe or modify the monitored data without being in the monitor.<P></A>
<A NAME="1035707">
Monitoring is about protecting data, not code. A <B>monitored invariant</B> is a Boolean expression over the monitored data. The expression may be false only when a thread is in the monitor (holding the monitor's mutex). This requirement implies that when a thread first enters the monitor, an evaluation of the invariant expression must yield a <CODE>true</CODE>. The thread must also reinstate the monitored invariant before exiting the monitor. Therefore, evaluation of the expression must also yield a true at that point in execution.<P></A>
<A NAME="1037867">
A trivial example might be as follows. Suppose an object has three values, <CODE>v1</CODE>, <CODE>v2</CODE>, and <CODE>sum</CODE>. The invariant is that the third value is the sum of the other two. Expressed mathematically, the invariant is <CODE>sum = v1 + v2</CODE>. Any modification of <CODE>v1</CODE> or <CODE>v2</CODE> requires modification of <CODE>sum</CODE>. Since that is a <I>complex</I> operation, it must be monitored. Furthermore, any type of access to <CODE>sum</CODE> must also be monitored to ensure that neither <CODE>v1 n</CODE>or <CODE>v2</CODE> are in flux. <P></A>

<B>Note: </B><a name="1035710">
Evaluation of the invariant expression is a conceptual requirement and is rarely done in 
practice. It is valuable to formally define the expression during design, write it down, and 
adhere to it. It is also useful to implement the expression during development and test it 
where appropriate. The thread makes an absolute assertion of the expression's evaluation 
both on entering and on exiting the monitor. 
</a>
<P><A NAME="1035711">
Acquiring a lock is a synchronous operation. Once the lock primitive is called, the thread returns only when it has acquired the lock. Should another thread (or the same thread) already have the lock held, the calling thread blocks, waiting for the situation to improve. That blocked state is not interruptible, nor is it timed. <P></A>

<A NAME="Head2;"></A>
<A NAME="1035612">
<H3> Condition Variables</H3>
</A>

<A NAME="1035725">
Condition variables facilitate communication between threads. The communication available is a semantic-free notification whose context must be supplied by the programmer. Conditions are closely associated with a single monitor. <P></A>
<A NAME="1037930">
The association between a condition and a monitor is established when a condition variable is created, and the association persists for the life of the condition variable. In addition, a static association exists between the condition and some data within the monitor. This data is what will be manipulated by the program under the protection of the monitor. A thread may wait on notification of a condition that signals changes in the state of the associated data. Other threads may notify the condition when changes occur. <P></A>
<A NAME="1035730">
Condition variables are always monitored. The relevant operations on conditions are always performed from within the monitor. They are used to communicate changes in the state of the monitored data (though still preserving the monitored invariant). Condition variables allow one or more threads to wait for a predetermined condition to exist, and they allow another thread to notify them when the condition occurs. Condition variables themselves do not carry the semantics of the state change, but simply provide a mechanism for indicating that something has changed. It is the programmer's responsibility to associate a condition with the state of the data. <P></A>
<A NAME="1035731">
A thread may be designed to wait for a particular situation to exist in some monitored data. Since the nature of the situation is not an attribute of the condition, the program must test that itself. Since this testing involves the monitored data, it must be done from within the monitor. The wait operation atomically exits the monitor and blocks the calling thread in a waiting condition state. When the thread is resumed after the wait, it will have reentered the monitor, making operations on the data safe.<P></A>
<A NAME="1038355">
There is a subtle interaction between the thread(s) waiting on a condition and those notifying it. The notification must take place within a monitor--the same monitor that protects the data being manipulated by the notifier. In pseudo code, the sequence looks like this: <P></A>
<A NAME="1038358">
<PRE>enter(monitor); <br>... manipulate the monitored data <br>notify(condition); <br>exit(monitor);</PRE></A><A NAME="1038362">
Notifications to a condition do not accumulate. Nor is it required that any thread be waiting on a condition when the notification occurs. The design of the code that waits on a condition must take these facts into account. Therefore, the pseudo code for the waiting thread might look like this: <P></A>
<A NAME="1038365">
<PRE>enter(monitor) <br>while (!expression) wait(condition); <br>... manipulate monitored data <br>exit(monitor);</PRE></A><A NAME="1038614">
The need to evaluate the Boolean expression again after rescheduling from a wait may appear unnecessary, but it is vital to the correct execution of the program. The notification promotes a thread waiting on a condition to a ready state. When that thread actually gets scheduled is determined by the thread scheduler and cannot be predicted. If multiple threads are actually processing the notifications, one or more of them could be scheduled ahead of the one explicitly promoted by the notification. One such thread could enter the monitor and perform the work indicated by the notification, and exit. In this case the thread would resume from the wait only to find that there's nothing to do. <P></A>
<A NAME="1038615">
For example, suppose the defined rule of a function is that it should wait until there is an object available and that it should return a reference to that object. Writing the code as follows could potentially return a null reference, violating the invariant of the function: <P></A>
<A NAME="1038379">
<PRE>
void *dequeue()
{
    void *db;
    enter(monitor);
    if ((db = delink()) == null)
    {
        wait(condition);
        db = delink();
    }
    exit(monitor);
    return db;
}
</PRE></A><A NAME="1038391">

The same function would be more appropriately written as follows: <P></A>
<A NAME="1038393">
<PRE>
void *dequeue()
{
    void *db;
    enter(monitor);
    while ((db = delink()) == null)
        wait(condition);
    exit(monitor);
    return db;
}
</PRE></A>

<A NAME="1035732">
<B>Caution: </B></A>
<a name="1035736">
The semantics of <CODE><A HREF="prcvar.html#1018626">PR_WaitCondVar</A></CODE> assume that the monitor is about to be exited. This 
assumption implies that the monitored invariant must be reinstated before calling 
<CODE>PR_WaitCondVar</CODE>. Failure to do this will cause subtle but painful bugs. 
</a>
<P><A NAME="1037977">
To modify monitored data safely, a thread must be in the monitor. Since no other thread may modify or (in most cases) even observe the protected data from outside the monitor, the thread can safely make any modifications needed. When the changes have been completed, the thread notifies the condition associated with the data and exits the monitor using <A HREF="prcvar.html#1018946"><CODE>PR_NotifyCondVar</CODE></A>. Logically, each such notification promotes one thread that was waiting on the condition to a ready state. An alternate form of notification (<A HREF="prcvar.html#1018977"><CODE>PR_NotifyAllCondVar</CODE></A>) promotes all threads waiting on a condition to the ready state. If no threads were waiting, the notification is a no-op. <P></A>
<A NAME="1035738">
Waiting on a condition variable is an interruptible operation. Another thread could target the waiting thread and issue a <A HREF="prthrd.html#1015726"><CODE>PR_Interrupt</CODE></A>, causing a waiting thread to resume. In such cases the return from the wait operation indicates a failure and definitively indicates that the cause of the failure is an interrupt. <P></A>
<A NAME="1035745">
A call to <CODE><A HREF="prcvar.html#1018626">PR_WaitCondVar</A></CODE> may also resume because the interval specified on the wait call has expired. However, this fact cannot be unambiguously delivered, so no attempt is made to do so. If the logic of a program allows for timing of waits on conditions, then the clock must be treated as part of the monitored data and the amount of time elapsed re-asserted when the call returns. Philosophically, timeouts should be treated as explicit notifications, and therefore require the testing of the monitored data upon resumption.<P></A>

<A NAME="NSPR Sample Code"></A>
<A NAME="1039835">
<H2> NSPR Sample Code</H2>
</A>
<A NAME="1039836">
The following links present two sample programs, <CODE><A HREF="prlayer.html">layer.c</A></CODE> and <CODE><A HREF="prswitch.html">switch.c</A></CODE>. In addition to being presented there as a series of listings separated by detailed descriptions, these samples are available in <A HREF="./samples/" TARGET="_blank">pure source form</A>.<P></A>


<P><HR>
<A HREF="contents.html">[Contents]</A> <A HREF="contents.html">[Previous]</A> <A HREF="prtyp.html">[Next]</A> <A HREF="prerr.html">[Last]</A>
<P ALIGN=right>

<FONT SIZE=-2><I>Last Updated: Mon Jul 13 15:31:58 PDT 1998</I></FONT>

<HR SIZE=4>

<P> <CENTER>Copyright © 1998
<A HREF="http://home.netscape.com/misc/contact_info.html"
TARGET=_top>Netscape Communications Corporation</A></FONT>
</CENTER>
<P>
<P>






</TD>


<TD VALIGN=TOP ALIGN=RIGHT>
</TD>


<TD BGCOLOR="#000000" VALIGN=TOP><IMG ALT=""
SRC="../../../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

</TR>


<TR>


<TD BGCOLOR="#000000" VALIGN=BOTTOM ALIGN=RIGHT><IMG ALT=""
SRC="../../../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#DDDDDD" VALIGN=BOTTOM><IMG ALT=""
SRC="../../../images/curve2.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#DDDDDD" VALIGN=BOTTOM ALIGN=RIGHT><IMG ALT=""
SRC="../../../images/curve4.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#000000" VALIGN=BOTTOM><IMG ALT=""
SRC="../../../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD VALIGN=BOTTOM COLSPAN=2><IMG ALT=""
SRC="../../../images/curve2.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD VALIGN=BOTTOM ALIGN=RIGHT><IMG ALT=""
SRC="../../../images/curve4.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#000000" VALIGN=BOTTOM ALIGN=RIGHT><IMG ALT=""
SRC="../../../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>
</TR>

<TR BGCOLOR="#000000">

<TD BGCOLOR="#000000" COLSPAN=5><BR></TD>

<TD BGCOLOR="#000000" VALIGN=TOP>

<FONT COLOR="#AAAAAA" SIZE="-1">
Copyright &copy; 1998-1999 The Mozilla Organization.
</FONT>

</TD>

<TD BGCOLOR="#000000" COLSPAN=2><BR></TD>
</TR>

</TABLE>
</BODY>
</HTML>
