<HTML>
<HEAD>
<TITLE>New Layout: XPFE</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000"
LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000"
MARGINHEIGHT=0 MARGINWIDTH=0>

<MAP NAME="banner">
<AREA SHAPE=RECT COORDS="300,11,558,44" HREF="http://www.mozilla.org/">
</MAP>

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#000000" VALIGN=TOP ROWSPAN=2><IMG
SRC="../images/mozilla-banner.gif"
ALT="" BORDER=0 USEMAP="#banner"
WIDTH=600 HEIGHT=58 VSPACE=0 HSPACE=0></TD></TR></TABLE>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR>


<TD BGCOLOR="#000000" VALIGN=TOP ALIGN=RIGHT><IMG ALT=""
SRC="../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#DDDDDD" VALIGN=TOP><IMG ALT=""
SRC="../images/curve1.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD BGCOLOR="#DDDDDD" VALIGN=TOP ROWSPAN=2>

<BR><TABLE CELLPADDING=0 CELLSPACING=3 BORDER=0>
<TR><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=19><A HREF="..//"><B> The Mozilla<BR>Organization</B></A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../mission.html"> Our Mission</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../about.html"> Who We Are</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../get-involved.html"> Getting Involved</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../community.html"> Community</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../advocacy.html"> Editorials</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../news.html"> What's New</A></TD></TR>
<TR><TD NOWRAP VALIGN=TOP COLSPAN=20><B></B></TD></TR>
<TR><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=19><A HREF="../development.html"><B> Development</B></A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../roadmap.html"> Roadmap</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../owners.html"> Module Owners</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../blue-sky/"> Blue Sky</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../projects.html"> Projects</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../status/"> Status</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../tools.html"> Tools</A></TD></TR>
<TR><TD NOWRAP VALIGN=TOP COLSPAN=20><B></B></TD></TR>
<TR><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=19><A HREF="../products.html"><B> Products</B></A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../source.html"> Source Code</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../binaries.html"> Binaries</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../docs/"> Documentation</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../NPL/"> License Terms</A></TD></TR>
<TR><TD></TD><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=18><A HREF="../bugs/"> Bug Reports</A></TD></TR>
<TR><TD NOWRAP VALIGN=TOP COLSPAN=20><B></B></TD></TR>
<TR><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=19><A HREF="../search"><B> Search</B></A></TD></TR>
<TR><TD VALIGN=TOP><IMG SRC="../images/bullet1.gif" ALT="" WIDTH=8 HEIGHT=8 HSPACE=2 VSPACE=3></TD><TD NOWRAP COLSPAN=19><A HREF="../feedback.html"><B> Feedback</B></A></TD></TR>
</TABLE><BR>

</TD>


<TD BGCOLOR="#DDDDDD" VALIGN=TOP ALIGN=RIGHT><IMG ALT=""
SRC="../images/curve3.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#000000" VALIGN=TOP><IMG ALT=""
SRC="../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD VALIGN=TOP><IMG ALT=""
SRC="../images/curve1.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD VALIGN=TOP ROWSPAN=2>
<P><BR>

<!doctype html public "-//w3c//dtd html 4.0 transitional//en">


   
   
   



<hr WIDTH="100%">
<h2>
Architecture</h2>
Author: <a href="mailto:kmcclusk@netscape.com">Kevin McCluskey</a>, <a href="mailto:rods@netscape.com">Rod
Spears</a>
<br>Updated: 10/23/98
<hr WIDTH="100%">
<br>&nbsp;
<table COLS=1 WIDTH="80%" BGCOLOR="#FFFFCC" >
<tr>
<td><b>Table of Contents</b></td>
</tr>
</table>

<ul>
<li>
<a href="#Overview">Overview</a></li>

<li>
<a href="#Brief History of GUI Development">Brief History of GUI Development</a></li>

<li>
<a href="#XPFE Requirements">XPFE Requirements</a></li>

<li>
<a href="#XPFE Architecture Overview">XPFE Architecture Overview</a></li>

<li>
<a href="#XPFE Architecture">XPFE Architecture</a></li>

<li>
<a href="#XPFE Roadmap">XPFE Roadmap</a></li>

<li>
<a href="#Dependencies">Dependencies</a></li>

<li>
Reference</li>

<ul>
<li>
<a href="xui.html">XUI</a></li>

<li>
<a href="datasource.html">DataSource Widgets</a></li>

<li>
<a href="widget_overview.html">Widget Toolkit History</a></li>
</ul>
</ul>

<table COLS=1 WIDTH="80%" BGCOLOR="#FFFFCC" >
<tr>
<td><a NAME="Overview"></a><b>Overview</b></td>
</tr>
</table>

<table WIDTH="80%" >
<tr>
<td><font size=+0>What is XPFE?</font>
<br>&nbsp;
<p>XPFE&nbsp; is <u><font color="#3333FF">Cross</font></u>-<u><font color="#3333FF">P</font></u>latform
<u><font color="#3333FF">F</font></u>ront
<u><font color="#3333FF">E</font></u>nd.
This simply means that the graphical user interface for the Netscape suite
of tools will be written once on top of cross-platform set of libraries.
One benefit of this approach is to isolate the native platform differences
into a single location (the widget toolkit) and provide a common set of
services for supporting both HTML form widgets and the Front-End graphical
user interface. XPFE is an enabling technology for building web based applications
on top of the NGLayout technology.&nbsp;
<p>NGLayout is a cross platform layout engine that was designed to be fast
and small. All of the platform specific code is isolated into two libraries:
<ul>
<li>
<i>GFX</i> - the graphics and rendering libraries. (Click <a href="http://www.mozilla.org/newlayout/doc/gfx.html">here</a>
for more detail)</li>

<li>
<i>Widget</i> - the cross platform widget toolkit. This is a set of interfaces
for creating and manipulating native widgets. Currently there are ports
to MS-Windows, X-Windows, and Macintosh. (Click <a href="widgettoolkit.html">here</a>
for more detail)</li>
</ul>

<center><img SRC="figure1.gif" height=170 width=292>
<br>Figure #1 - NGLayout</center>

<p>Today most apps are written using an application framework such as MFC
on Windows, or PowerPlant on the MAC. Since XPFE is cross-platform it must
provide its own framework for building applications. XPFE relies on NGLAYOUT
to provide the core of this cross-platform framework. XPFE adds additional
widgets and layout behavior.
<p>XPFE is a set of libraries and services that will enable the developer
to create complete cross platform applications. XPFE is a layered on top
of the GFX and Widget libraries and takes advantage many different parts
of NGLayout for the creation and layout of GUI components.
<p>The visual representation of the GUI is described in a cross platform
resource file. The syntax for the resource file is a standard tag based
mark up language (XML). Applications that are written with XPFE can have
their GUI dynamically loaded at run-time. This enables the application
to "expose" varying degrees of functionality depending on the GUI resource
file that is loaded. This approach also provides a great deal of flexibility
for internationalization and localization.&nbsp;
<p>Once the application is up and running, the GUI can be augmented with
additional widgets/controls (i.e. additional toolbars or toolbar buttons)
from an external source, such as visiting a web site.&nbsp;
<p>&nbsp;</td>
</tr>
</table>

<table COLS=1 WIDTH="80%" BGCOLOR="#FFFFCC" >
<tr>
<td><a NAME="Brief History of GUI Development"></a><b>Brief History of
GUI Development</b></td>
</tr>
</table>

<table WIDTH="80%" >
<tr>
<td>When GUI applications were first developed many developers intertwined
the core application code with the GUI code. This is often done because
the developer gets confused on the difference between the "state" of the
GUI and the "state" of the application (see figure #2)
<br>&nbsp;
<br>&nbsp;
<br>
<center>
<p><img SRC="figure3.gif" height=134 width=293>
<br>Figure #2 - Original GUI applications</center>

<p>These types of applications were quickly discarded or re-written so
the GUI code was separate from the application code. The visual representation
of the GUI was either hard coded or defined in a resource file (see figure
#3). This made the applications much easier to maintain and add new features.
<center>
<p><img SRC="figure4.gif" height=178 width=427>
<br>Figure #3 - Separation of GUI Code from Application</center>

<p>A problem still exists that GUI developers are still tempted to mix
application and GUI code because the interface between the the application
and GUI is not always well defined.</td>
</tr>
</table>

<table COLS=1 WIDTH="80%" BGCOLOR="#FFFFCC" >
<tr>
<td><a NAME="XPFE Requirements"></a><b>XPFE Requirements</b></td>
</tr>
</table>

<table WIDTH="80%" >
<tr>
<td><b>XPFE has two main requirements:</b>
<ul>
<li>
XPFE must be cross-platform (at least MS-Windows, XWindows, and Mac)</li>

<li>
XPFE must support a downloadable UI, where some or all of the UI can be
downloaded.</li>
</ul>
<b>Requirement #1 - Cross Platform</b>
<br>The challenge of creating a cross-platform GUI is:
<ul>
<li>
Create a full-fledged, UI rich application using cross-platform widgets</li>

<li>
The availablility of a common set of GUI widgets. The UI either ends up
with the "Least Common Denominator" set of widgets or the widget set on
any given native platform is augmented to match the other toolkits.</li>

<li>
Defining a common resource format for externally describing the static
user interface. A resource file provides a flexible approach because the
UI can be changed without having to re-compile the application.</li>

<li>
The existence of a file reader for the external resource format and the
conversion of that data into an internal data structure that represents
the widget hierarchy.</li>

<li>
A cross-platform layout manager.</li>
</ul>
Existing Raptor technology provides a solution for each of the cross-platform
requirements:
<ul>
<li>
The widget toolkit provides a common set of widgets. Missing widgets on
a particular platform (that are available on other native platforms) can
be be written natively or written in a cross-platform manner using GFX.</li>

<li>
HTML, XML, or any ML can be used to describe the the static layout of the
GUI.</li>

<li>
Raptor provides an HTML and XML parser and Content Sink. There are DOM
APIs into the Content to enable the the getting and setting of widget properties.</li>

<li>
Raptor provides a layout engine for laying out the widgets using HTML.</li>
</ul>
<b>Requirement #2 - Downloadable Chrome</b>
<br>The challenge of providing downable chrome is:
<ul>
<li>
Some or all of the chrome needs to be downloaded</li>

<ul>
<li>
Is the chrome description completely declaritive or can it be created through
a scritping language?</li>

<li>
Can the behavior that is associtaed with the chrome be downloaded and "installed"?</li>

<li>
How can local chrome and NetCenter chrome be merged?</li>
</ul>

<li>
Complete separation of GUI static description, GUI "glue" code and the
"core" application</li>

<li>
Chrome must support CSS</li>
</ul>
Existing Raptor technology provides a solution for the downloadable chrome
issues:
<ul>
<li>
A combination of XML and HTML can be used to describe the entire UI. For
example the all menus, toolbars, dialogs, etc.</li>

<li>
XML/HTML provides a completely declarative description of the chrome and
Java Script can be used for dynamic creation of chrome.</li>

<li>
In an extreme case the entire application behavior can be written in JavaScript
and downloaded as part of the chrome.</li>

<li>
Local and non-local chrome can be parsed and fed into RDF for UI merging.</li>

<li>
Both XPCOM and JavaScript interfaces provide a great deal of flexibility
in separating the GUI definition, the GUI "glue" code, and the main application
components.</li>
</ul>
</td>
</tr>
</table>

<table COLS=1 WIDTH="80%" BGCOLOR="#FFFFCC" >
<tr>
<td><a NAME="XPFE Architecture Overview"></a><b>XPFE Architecture Overview</b></td>
</tr>
</table>

<table WIDTH="80%" >
<tr>
<td>XPFE can be used as the foundation for building many different types
of applications. It enforce a clean separation between the application
code and the GUI code. Many, if not all, of NGLayout's components exist
as simple interfaces. Interfaces by their nature enforce this clean separation
because the implementation is hidden. XPFE is ideal for creating web based
application with the UI expressed in terms of some markup language.
<p>XPFE is made up of several different components. These components taken
as a whole make up the "core" XPFE functionality. Then, any number of GUIs
can be built on top of the core. The core XPFE components are as follows:
<ul>
<li>
A markup definition for describing the visual representation of the GUI</li>

<li>
An API for creation of HTML/XML based Windows and Dialogs</li>

<li>
A layout manager for laying out Windows and dialogs. NGLayout will be used
for most windows and dialogs, although special layout managers may exists
for handling special cases (i.e. the application window)</li>

<li>
Interfaces for manipulating the GUI components</li>

<li>
Extensions to the Widget toolkit. Implementation of non-HTML based forms
widgets like: toolbars, menus, status bar, url bar, etc.)</li>
</ul>
Applications written on top of the core XPFE functionality provide the
following functionality:
<ul>
<li>
The resource definition (HTML/XML) describing the visual representation
of the UI</li>

<li>
The event callback code for the GUI</li>

<li>
The core application components that are being manipulated through the
GUI.&nbsp;</li>
</ul>
Figure #4 shows a very high level diagram of this paradigm. The application
reads in the HTML/XML at startup, as the mark up is parsed, a new UI document
is created containing a GUI content model. The UI document is then used
to create an NGLayout WebShell that creates the UI components and lays
them out. The layout process can be NGLayout's HTML-based layout or other
layout managers may be installed to produce the desired layout.
<br>&nbsp;
<br>&nbsp;
<br>
<br>
<center>
<p><img SRC="figure2.gif" height=238 width=424>
<br>Figure #4 - XPFE</center>

<p>A more specific use of XPFE is shown below in Figure #5 where the Application
Core may be the WebWidget, the Application Services is RDF containing the
bookmarks. The GUI developer creates the necessary HTML/XML for describing
a browser UI and then writes the callback "glue" code for hooking up the
UI to the WebWidget.
<center>
<p><img SRC="figure6.gif" height=292 width=376>
<br>Figure #5 - XPFE Application</center>
&nbsp;</td>
</tr>
</table>

<table COLS=1 WIDTH="80%" BGCOLOR="#FFFFCC" >
<tr>
<td><a NAME="XPFE Architecture"></a><b>XPFE Architecture</b></td>
</tr>
</table>

<table WIDTH="80%" >
<tr>
<td><b>Introduction</b>
<p>XPFE includes both core technology and a structure for applications.
The XPFE architecture allows the application's user-interface can be written
in a combination of C++ and JavaScript. Parts of the core application or
it's user-interface can be progressively exposed as JavaScript routines.
The core technology within XPFE includes existing widgets, new widgets
and integration within NGLAYOUT for reading and displaying documents describing
user interface for windows and dialogs.
<p>The following description of a specific implementation will walk you
through the architecture and provide a general idea of how it works. Each
of the components in the diagram are describe in detail below.
<p>Assume that there is a browser application built from XPFE, the application
flow would be as follows:
<ul>
<li>
A new class is dervied from "AppShell" that contains the App UI.&nbsp;</li>

<li>
The browser App UI is created and it contains a dispatch object is for
servicing all the GUI events</li>

<li>
The App UI gets an instance of XUI Manager and asks it to load the initial
XUI document, this returns a XUI Main Window</li>

<ul>
<li>
The XUI document is parsed by the NGLayout parser with the XUI-DTD and
the XUI Content model is created</li>

<li>
When the Main Window is shown the XUI manager talks to the XUI Content
model (frame model) and all the UI elements defined in the XUI document
are layed out</li>
</ul>

<li>
The App Shell registers it's dispatch object as a listener of the XUI Main
Window</li>

<li>
All events are relayed to the dispatch object within the App Shell</li>

<li>
The dispatch object calls methods on the App UI, the App UI then makes
additional calls on the App Core and App services for performing work</li>
</ul>

<center><img SRC="XPFEArchitecture.gif" height=768 width=588>
<br>Figure #6 - The XPFE Architecture
<br><b><font size=+1>XPFE Architecture Diagram</font></b>
<br><b><font size=+1>(Preliminary 10-22-98)</font></b></center>

<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<p><b>Design philosophy</b>
<p>The core design is based on a separation of the application user-interface
and the application core. In addition, dispatch code should be separated
from the application's user-interface.
<p><b>App UI</b>
<p>The application user-interface contains code to display dialogs and
top-level windows. It also contains all of the code to process any events
comming from the dialogs or windows.
<p><b>App Dispatch</b>
<p>The code to dispatch events to the Application's user interface is placed
in a separate module so that application dispatch can come from different
sources including JavaScript.
<p><b>App Core</b>
<p>The application core provides an API that can be called from the Application
User-Interface. The core <u>should not</u> contain code to create or manage
MenuBars or Dialogs. In addition, it should not contain code to process
top-level windows and dialogs. This code should be placed in the App UI
instead. An example of an App Core is the WebWidget.
<p>All of the code for performing direct manipulation&nbsp; <u>should</u>
be placed in the AppCore. An example of this is the WebWidget. The code
to process clicks on links and scrolling of the WebWidget should reside
in the AppCore. In the case of the "ender widget" all of the code to process
selection should be placed in the AppCore. Ifthe App UI needs information
from the AppCore such as "is there a current selection" so that it can
disable or enable a toobar button, this information should be provided
to the App UI either through method calls or event listeners. In addition
to direct manipulation, drag and drop processing should be included in
the App Core as well.&nbsp; For many applications it should be possible
to embedd the App Core in a page by specifying an object tag which has
a reference to the AppCore. If the AppCore needs additional UI then it
can be accomplished in two ways. The App Core can&nbsp; expose JavaScript
functions which allow a&nbsp; XUI/HTML with JavaScript event handlers make
calls into the AppCore. This allows the external interface ("i.e. non direct
manipulation) to be controlled by the page designer. An alternative is
to have the object tag refer to a combination of App UI and AppCore. The
AppUI in this case would not contain the full user-interface that a stand-alone
application would provide. This corresponds to what the "ender" widget
does today.
<p><b>App Services</b>
<p>The application services include HT/RDF, I10N, and other modules which
will be used across applications.
<p><b>UI Mgr</b>
<p>The User Interface Manager is responsible for creating dialogs and top
level windows. It also is reponsible for attaching an event listener to
the dialog or window.
<p><b>Listener</b>
<p>The listener interface is used to dispatch events generated by windows
and dialog boxes. The events dispatched include high-level CLICK as well
as low level MOUSE_DOWN and MOUSE_UP events.
<p><b>AppShell</b>
<p>The Application shell contains the startup code for each native platform.
It also contains the message pump. The Application UI is a sub-class of
the application shell.
<p><b>XUI Document</b>
<p>The XUI Document is a XML-based grammer for describing the layout of
top-level windows and dialogs. It contains tags for specifying menubars,
toolbars, statusbars, and tree controls.
<p><b>XUI Layout manager</b>
<p>The layout of the XUI elements is done using a XUI layout manager. It
is anticpated that the HTML Layout manager will not be sufficient to layout
menubars,toolbars, statusbars, and tree controls properly. Rather than
trying to add new behavior to the HTML Layout manager a new XUI Layout
Manager mantains the layout of XUI Content.
<p><b>HTML + OBJECT Tag</b>
<p>In some cases it is desirable to have the new widgets layed out by the
HTML layout manager (Raptor). If this is the case, then the widget will
be specifyable through the OBJECT tag syntax in HTML. Tree widgets are
an example of a widget which you may want to layout both within a HTML
Table within a dialog or within the Top-level XUI described window. It
is expected that you should be able to insert a tree widget either within
XUI or using the OBJECT tag within HTML. We may decide to allow a XUI document
to be referenced through the OBJECT tag to so that a HTML document could
take advantage of the XUI Layout manager within a region of the HTML dialog
or window.
<p><b>CSS</b>
<p>Stylistic information for XUI/HTML documents is stored in CSS rules.
Each of the XUI elements includes a <i>classid</i> and <i>id</i> attribute
so that it can be bound to style information provided by CSS. The <i>id</i>
attached to XUI elements within the XUI Document will also be used for
event dispatch to identify the widget.
<p><b>Content Model</b>
<p>As the XUI Document is parsed XUI specific content is created. The Content
that is created implements the nsIHTMLContent interface so that XUI Content
can live in both the HTML Content area of the special XUI Content area.
<p><b>DOMXUI + DOMHTML interfaces</b>
<p>The XUI Content is accessible through nsIDOMXUI Interfaces. These interfaces
are defined through IDL and compatible with the nsIDOMHTML Interfaces defined
for standard HTML elements. These interfaces provide programatic access
to the widgets from C++ and later JavaScript. The bulk of the App UI Code
will involve calls to these interfaces. Since the nsIDOMXUI Interfaces
are similar to the nsIDOMHTML interfaces it should make it easy for programmers
to migrate UI code that was written in C++ to JavaScript.
<p><b>CSS Style interfaces</b>
<p>In addition to having access to the DOMXUI and DOMHTML interfaces, Application
UI developers will also have access to a CSS Style DOM. This DOM contains
API's for changing the style of the UI elements. This includes there colors
and icons, etc.
<p><b>JavaScript (Security)</b>
<p>When JavaScript is introduced there are security concerns. A site containing
JavaScript could change your menu's so that your application no longer
functioned properely or worked at all. If all of the UI elements are exposed
to JavaScript there are&nbsp; an even more places that an errant JavaScript
program could cause problems. In addition, the application core and application
ui can expose methods to JavaScript which may give them indirect access
to the filesystem and other OS services. One solution is limit the number
of functions that are accessible through JavaScript.&nbsp; A more general
solution is to differentiate between the JavaScript that exists in a page
that is downloaded and the JavaScript that is referenced from the Page.
The JavaScript within the page would not have access to any UI elements,
App Core, or App UI functions. The JavaScript referenced from this page
would be signed JavaScript and would have access to the UI elements, App
Core, and App UI functions.
<p><b>Downloadable Chrome</b>
<p>There are four different approarches to downloading the chrome using
XPFE. They can be used separately or in combination. It is expected final
and most general form of downloadable chrome will not be available in the
first release of XPFE.
<p>Complete UI Replacement
<blockquote>It is expected that you should be able to download XUI + HTML
files which replace the entire user-interface, but not change the fundamental
architecture of user-interface. For example, you may substitute a "Kid
Friendly" user interface for the browser which contains different a different
set of icons on the toolbar and changes each dialog box to be more kid
oriented. In this scenario you can only replace the existing XUI+HTML files
with new files that contain a subset of the widgets in the original UI.
This can be achieved without adding an JavaScript. The application ui would
be responsible for initiating the download of the replacement files.</blockquote>

<p><br>Replacement of Some UI Elements
<blockquote>The replacement of a single UI element such as a toolbar can
be accomplished just like the Complete UI Replacement. The application
UI would be responsible for initiating the download of a toolbar or other
UI element. The original XUI/HTML files describing the element would probably
have a reference to a another XUI/HTML file that contained the replacement
UI component.</blockquote>

<p><br>Merging of Local and Remote UI Elements
<blockquote>Some UI's components such as toolbars may actually be defined
by combining a remote definition of toolbar created by NetCenter and a
local defintion of a toolbar. In this case, the local and remote toolbar
definitions will be read in to a RDF data store. RDF provides the ability
to merging the local and remote toolbar definitions. The toolbar would
get it's contents from a datasource which understands how to get and set
data in the RDF datastore. This capability could be used by NetCenter or
other web-sites to dynamically add new toolbars or menu items to the user
interface. One the UI elements are merged they will be kept a local data
store by saving the RDF datastore to disk.</blockquote>

<p><br>JavaScript Controlled Merging
<blockquote>JavaScript provides the ultimate control for merging, replacing,
and removing UI elements. If we assume that we have exposed the full api's
to the UI Manager, Application UI, and provided JavaScript DOMXUI interfaces.
Since JavaScript would have access to the entire User interface it could
dynamically create&nbsp; and insert new UI elements or remove UI elements.
This full control would only be available to signed JavaScript however.&nbsp;
In order to cleanup the UI elements created by the JavaScript code, the
content developer will need to have an OnUnload JavaScript event handler
registered which selectively removes any of the UI elements it added.</blockquote>

<p><br><b>Event Model</b>
<p>The event model used in XPFE is the NGLAYOUT event model.&nbsp; Within
NGLAYOUT events are managed and dispatched through view and frame systems.&nbsp;
For the App UI engineer this results in be able to insert a listener on
either the window or dialog or listen to an individual widget.
<p><b>Localization (I10N)</b>
<p>Localization within a XUI/HTML document is done primarly through resource
URL's which contain a key used to retrieve the actual string for widget
labels.
<p><b>New Widgets</b>
<p>Creating a professional user-interface requires very a specific set
of widgets. The existing set of widgets's within NGLAYOUT are adequete
for defining HTML form elements, but are not sufficient for doing a browser
or editor interface. The set of widget's within NGLAYOUT will be extended
to include:
<ul>
<li>
Menubars</li>

<li>
Tree Widgets</li>

<li>
Status Bars</li>

<li>
Progress Bars</li>

<li>
Collapso/Expando</li>

<li>
Tri-state checkbox</li>

<li>
Tab control</li>

<li>
Drop down button</li>

<li>
Color picker</li>

<li>
File Picker</li>

<li>
Calendar Widget</li>

<li>
"Grippy pane"</li>

<li>
Location bar</li>
</ul>

<p><br>This new widgets will either be implemented natively on each platform
or they will be completely cross-platform (i.e. rendered by the GFX library).
<p><b><a href="datasource.html">DataSource Widgets</a></b>
<p>Some widgets tend have a large amount of "state" data that must be maintained.
If there are multiple sources for the data, keeping the data in sync becomes
an issue. To solve this problem, some of the new widgets will get their
data from a "data source". This is basically the Model/View/Controller
paradigm for widgets. With this approach only one copy to widget's data
needs to be maintained. Tree widgets and toolbars are candidates for this
approach.&nbsp;
<p><b>RDF</b>
<p>RDF will be used primary as a service for getting and merging local
and remote data. It may also be used to store the data used by the XUI
Content. In this case there would still be content added to the standard
content model, but the content would retrieve and set data in the&nbsp;
RDF data source. Since the XUI file contains CSS, the CSS style rules would
also have to be converted to RDF data. This is desirable because RDF has
capabilities for merging data. This merging capability could be used to
merge a local and remote definition of a toolbar, menu, or other ui elements.
Merging of CSS rules requires more investigation.
<p><b>Modal Dialogs</b>
<ul>
<li>
The UIManager does not return from the call to Modal dialogs until the
event listener attached to the dialog executes a the dialogs close method.</li>

<li>
The interface to the widget that caused the termination of the modal dialog
is returned by the <i>ShowModalDialog</i> method.</li>

<li>
This widget interface can be used to determine if the "OK", "Cancel" button
or some other widget terminated the interaction.</li>

<li>
Each of the XUI/HTML widgets can be assessed through a nsDOM XUI or nsDOMHTML
or interface. This interface can be used to set and retrieve widget settings.</li>
</ul>

<p><br><b>Modeless Dialogs and TopLevelWindows</b>
<p>Modeless dialog behave in a similar manner to modal dialogs. The event
listener registered for the modeless dialog receives widget events. The
event listener contains code which has access to he widgets within the
dialog using the nsIDOMXUI and nsDOMIHTML interfaces.
<p><b>Adding and Removing XUI/HTML widgets</b>
<p>All manipulation of the HTML widgets is done through a C++ interface
DOMHTML interface. The XUI widgets are modified through a C++ DOMXUI interface.
<p><b>IDL</b>
<p>Interface definition language provides a language neutral way of describing
user-interfaces. NGLAYOUT includes a IDL compiler which can be used to
generate both XPCOM interfaces callable from C++ and glue code to make
the interface callable for JavaScript. The interfaces with XPFE should
use IDL to allow the interfaces to be accessable from both languages.
<p><b>Testing</b>
<p>Since XPFE-based applications separate the UI from the Application it
should be possible to provide automatic testing suites which exercise the
application core and applcation UI independently. If the Application UI
and App Core provide JavaScript interfaces, a test harness may be written
in JavaScript rather tan C++. A JavaScript test harness could be downloaded
from a site which would simply the testing process.
<p><b>Design Advantages</b>
<p>Since the design leverages NGLAYOUT for most everything the executable
size should remain very small.
<p>Access to the widgets for the C++ programmer and JavaScript programmer
are very similar. They both go through the DOM. This will make it easier
to convert C++ code into JavaScript Code.
<p>The separation of the Application UI from the Application Core should
make it easier to produce "ender like" and "web-widget"&nbsp; page-embeddable
applications.
<p>Since most of the API's will be exposed through IDL, it should be straightforward
to expose the interfaces to JavaScript.
<p>Even though we initially store XUI and HTML elements in different content
model locations,<font color="#3333FF"> </font><font color="#000000">it
should be possible to move the new XUI elements directly in the HTML tree
at a later date in a straight forward manner</font><font color="#3333FF">.
</font>Since
from the beginning they use implement the nsIHTMLContent interface. In
addition we may need to insert some widgets into both the XUI and HTML
content models. A tree widget is an example of this. Sometimes we want
the tree control to be layout out in a dialog using an HTML table layout.
Other times we want the tree to be layout out on the top-level window as
a pane using the XUI LayoutManager (similar to Aurora chrome).
<p><b>Design Disadvantages</b>
<p>Since the design leverages NGLAYOUT for most everything, working on
XPFE requires a deep understanding of NGLAYOUT.
<p>XPFE does not use a typical application framework for managing UI, instead
it uses NGLAYOUT framework. Engineers familiar with standard application
frameworks such as MFC or PowerPlant will have to learn this new framework.
<br>&nbsp;
<br>&nbsp;
<p>
<hr WIDTH="100%">
<p><b>nsUIManager</b>
<p>Provides an interface for creating and displaying windows and dialogs.
<br>There is one UI Manager per application. This does not mean per executable,
since there may be more than one application within a single executable
ala Netscape Communicator suite.&nbsp; The justificiation for this that
we want to be able to determine the set of windows opened by a particular
application.
<p><tt><font color="#000099">class nsIUIManager : public nsISupports</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#006600">&nbsp; // nsISupports</font></tt>
<br><tt><font color="#000099">&nbsp; NS_DECL_ISUPPORTS</font></tt>
<p><tt><font color="#006600">&nbsp; // nsIUIManager</font></tt>
<p><tt><font color="#006600">&nbsp; // Methods to open a various types
of windows.</font></tt>
<p><tt><font color="#006600">&nbsp; // The modal dialog is brought down
when the close method is called</font></tt>
<br><tt><font color="#006600">&nbsp; // from within the eventListener code
below. The terminating widget</font></tt>
<br><tt><font color="#006600">&nbsp; // is returned from as well. This
method implies that the modal dialog is</font></tt>
<br><tt><font color="#006600">&nbsp; // actually a full webshell that does
a LoadURL to get the document. It may</font></tt>
<br><tt><font color="#006600">&nbsp; // Have to instal the XUI DTD and
ContentSink before proceedding.</font></tt>
<p><tt><font color="#000099">&nbsp; NS_IMETHOD OpenModalDialog(nsIWidget*
aContainerWidget, nsURL aUrl,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nsIUIWindow &amp;*aWindow, nsIEventListener, nsIDOMHTMLElement &amp;*terminatingWidget);</font></tt>
<p><tt><font color="#006600">&nbsp; // aContainerWidget : This is typically
the widget associated with a top</font></tt>
<br><tt><font color="#006600">&nbsp; // level window.</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD OpenModelessDialog(nsIWidget*
aContainerWidget, nsURL aUrl,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nsIUIWindow &amp;*aWindow);</font></tt>
<p><tt><font color="#000099">&nbsp; NS_IMETHOD OpenTopLevelWindow(nsIWidget*
aContainerWidget, nsURL aUrl,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nsIUIWindow &amp;*aWindow);</font></tt>
<p><tt><font color="#000099">}</font></tt>
<p><b>nsUIWindow</b>
<p>Subclass of a Browser window which works with both XUI and HTML.
<br><font size=-1>Note: nsIBrowserWindow contains unwanted extra capabilities
that nsIUIWindow</font>
<br><font size=-1>may not want to support. We may want to factor nsIBrowserWindow
functionality such</font>
<br><font size=-1>as the UI controls for manipulating toolbars, etc. to
a new nsINavigatorWindow class.</font>
<p><tt><font color="#000099">class nsUIWindow : public nsIUIWindow, nsIBrowserWindow</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // Return the nsIWidget that
the UIWindow uses for rendering.</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // This widge can be used to
bring up widgets which are not encoded</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // with XUI and are not placed
in the content model.</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // The FileSelector widget is
a good example. When this</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // Widget is brought up it needs
a parent widet in which to display.</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD <b>GetWidget</b>(nsIWidget
&amp;*aWidget);</font></tt>
<p><tt><font color="#006600">&nbsp;&nbsp; // METHODS For retrieving the
content from the window. These methods are used after</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // a modal dialog has been displayed
and the app needs to see the current</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // settings. They are also used
by modeless and top-level windows to retrieve settings</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // in response to user generated
events.</font></tt>
<p><tt><font color="#006600">&nbsp;&nbsp; // - RATHER Than providing direct
manipulating of the widget's attributes. All manipulation is</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // Done through a content model.
This allows the HTML content and XUI content to manipulated in a uniform
manner.</font></tt>
<p><tt><font color="#006600">&nbsp;&nbsp; // Search the content model for
a piece of content with the id specified. This</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // id matches the id attribute
in the XUI file. It also matches the HTML attribute id.</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // A nsIDOM interface to the
content is returned. This allows a uniform mechanism for</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // Manipulating the data.</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // Note this method will search
both the XUI content model and the HTML content model for aId.</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // It will return with the first
Id it finds. Id's should be unique since there is not</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // a mechanism for getting a
duplicate id (you will always get the first.)</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD GetContent(nsString
aId, nsIDOMHTMLElement &amp;*aContent);</font></tt>
<br>&nbsp;
<p><tt><font color="#006600">&nbsp;&nbsp; // Sets up an event listener
for any NS_EVENT. The listener will get the event after</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // There are two types events
that will be typically listened for.</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // NS_MENU selection events
if a menu is precent. NS_UP events.</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; // The widget which generated
the event is stored in the event structure. It may</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp; //</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD SetListener(nsIEventListener
&amp;aListener);</font></tt>
<p><tt><font color="#000099">}</font></tt>
<p><tt><font color="#FF6666">// LOOK At the existing listener interface
within NGLAYOUT. This is probably all we need. Don't need another listener
interface.</font></tt>
<p><tt><font color="#000099">class nsIEventListener {</font></tt>
<p><tt><font color="#006600">&nbsp; // This method gets called when the
an event is generated by a widget.</font></tt>
<br><tt><font color="#006600">&nbsp; // Note event pased through is a high-level
synthesized event such</font></tt>
<br><tt><font color="#006600">&nbsp; // as NS_CLICK instead of NS_MOUSE_DOWN,
NS_MOUSE_UP.</font></tt>
<p><tt><font color="#006600">&nbsp; // In the case of MENU events, or Button
clicks on toolbars.</font></tt>
<br><tt><font color="#006600">&nbsp; // This method should be overriden
to call a Application Core method</font></tt>
<br><tt><font color="#006600">&nbsp; // ASAP. Ideally there should be no
process inside. This allows the</font></tt>
<br><tt><font color="#006600">&nbsp; // Dispatching code to be isolated
from the Application Core. Later</font></tt>
<br><tt><font color="#006600">&nbsp; // The Application Core may receive
calls to its methods from a different</font></tt>
<br><tt><font color="#006600">&nbsp; // dispatch mechanism such as JavaScript.</font></tt>
<p><tt><font color="#006600">&nbsp; </font><font color="#FF6666">// TBD,
How to plug into NGLAYOUTS frame system to get</font></tt>
<br><tt><font color="#FF6666">&nbsp; // the higher level event notification.</font></tt>
<p><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD Event(nsEvent &amp;aEvent);</font></tt>
<p><tt><font color="#006600">&nbsp; // Retreives the an interface to the
content which initiated the event.</font></tt>
<br><tt><font color="#006600">&nbsp; // XXX: To be determined, How to plug
into NGLAYOUTS frame system to get</font></tt>
<br><tt><font color="#006600">&nbsp; // the higher level event notification.</font></tt>
<p><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD GetContent(nsEvent
&amp;aEvent, nsIDOMHTMLElement &amp;*Event);</font></tt>
<p><tt><font color="#000099">}</font></tt>
<br>&nbsp;
<p><tt><font color="#FF6666">//XXX: FILL IN, Look at how content is added
through the existing HTML</font></tt>
<br><tt><font color="#FF6666">// DOM Intefaces.</font></tt>
<br>&nbsp;
<p><tt><font color="#006600">// Apps subclass this to initialize their
application.</font></tt>
<br><tt><font color="#006600">// The default behavior is to load a single
document which can come</font></tt>
<br><tt><font color="#006600">// from the command line. If no document
is specified "interface.xui" is loaded from</font></tt>
<br><tt><font color="#006600">// the current directory.</font></tt>
<p><tt><font color="#000099">class nsAppShell</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp;&nbsp; // Initialize the starting
window for the application.</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp;&nbsp; // This method is typically
overridden so the application can</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp;&nbsp; // Load the initial window
XUI file and to add new menu items and</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp;&nbsp; // toolbar items based
on preferences.</font></tt>
<br><tt><font color="#000099">&nbsp; virtual void initialize();</font></tt>
<br><tt><font color="#000099">}</font></tt>
<br>&nbsp;
<br>&nbsp;
<p><tt><font color="#000099">// Native shells</font></tt>
<p><tt><font color="#000099">class nsMacShell</font></tt>
<br><tt><font color="#000099">{</font></tt>
<p><tt><font color="#000099">}</font></tt>
<p><tt><font color="#000099">class nsWindowsShell {</font></tt>
<p><tt><font color="#000099">}</font></tt>
<p><tt><font color="#000099">class nsMotifShell {</font></tt>
<p><tt><font color="#000099">}</font></tt>
<br>&nbsp;
<p><tt><font color="#000099">class XUILayout {</font></tt>
<p><tt><font color="#000099">}</font></tt>
<p><tt><font color="#006600">// Here are the NSIDom Interfaces for the
new widgets.</font></tt>
<br><tt><font color="#006600">// Note that they are derived form nsDOMHTMLElement
so they will have a GetId</font></tt>
<br><tt><font color="#006600">// and SetId method that will be used to
identify the element within a dialog box</font></tt>
<br><tt><font color="#006600">// or top-level window.</font></tt>
<p><tt><font color="#006600">// These are the only thing that the UI code
should talk to</font></tt>
<br><tt><font color="#006600">// XXX:Talk with Vidur about how approprate
it is to call these things DOM since</font></tt>
<br><tt><font color="#006600">// they are not part of the DOM spec.</font></tt>
<p><tt><font color="#006600">// These classes are generated from idl's.</font></tt>
<p><tt><font color="#006600">// XXX: In the prototype there is a XUI ToolbarManager.</font></tt>
<br><tt><font color="#006600">// Layout for the toolbars could be done
by a XUI Layout manager and other</font></tt>
<br><tt><font color="#006600">// code for showing toolbars in their collapsed
state moved to the toolbar itself.</font></tt>
<br><tt><font color="#000099">class nsIDOMXUIToolbarManager : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD GetElements(nsIDOMHTMLCollection**
aElements) = 0;</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD CollapseToolbar(nsIToolbar
* aToolbar);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD ExpandToolbar(nsIToolbar
* aToolbar);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD AddToolbarListener(nsIToolbarManagerListener
* aListener);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD Resize(PRUint32 aWidth,
PRUint32 aHeight, PRBool aRepaint);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD Resize(PRUint32 aX,&nbsp;
PRUint32 aY, PRUint32 aWidth, PRUint32 aHeight, PRBool&nbsp;&nbsp; aRepaint);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD SetCollapseTabURLs(const
nsString&amp; aUpURL,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const nsString&amp; aPressedURL,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const nsString&amp; aDisabledURL,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const nsString&amp; aRollOverURL);</font></tt>
<p><tt><font color="#000099">&nbsp;&nbsp; NS_IMETHOD SetExpandTabURLs(const
nsString&amp; aUpURL,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const nsString&amp; aPressedURL,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const nsString&amp; aDisabledURL,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const nsString&amp; aRollOverURL);</font></tt>
<br><tt><font color="#000099">}</font></tt>
<br>&nbsp;
<p><tt><font color="#006600">// Initially only the nsIDOMXUI widgets nsIDOMImageButton
nad nsIDOMXUILocationBar and nsIDOMXUIThrobber</font></tt>
<br><tt><font color="#006600">// Can be added to a toolbar. Later any nsIDOMHTML
element could be added.</font></tt>
<br><tt><font color="#006600">// The issue with doing this at this time
is that it implies that there are HTML form elements hanging</font></tt>
<br><tt><font color="#006600">// directly off the toolbar element in the
XUI content tree. It also implies that the XUI definition file is</font></tt>
<br><tt><font color="#006600">// capable of expressing any HTML element.
The general approach probably is to do the same as thing as the HTML 4.0</font></tt>
<br><tt><font color="#006600">// button object here.</font></tt>
<p><tt><font color="#000099">class nsIDOMXUIToolbar : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD GetElements(nsIDOMHTMLCollection**
aElements) = 0;</font></tt>
<p><tt><font color="#006600">&nbsp;&nbsp;&nbsp; // XXX: These should be
expressed through the CSS style instead. With a combination</font></tt>
<br><tt><font color="#006600">&nbsp;&nbsp;&nbsp; // of states and psedudo
classes in the style systems make this work.</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD SetHorizontalLayout(PRBool
aDoHorizontalLayout);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD SetHGap(PRInt32
aGap);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD SetVGap(PRInt32
aGap);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD SetMargin(PRInt32
aMargin);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD SetLastItemIsRightJustified(const
PRBool &amp; aState);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD SetNextLastItemIsStretchy(const
PRBool &amp; aState);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD SetDrawFullBorder(PRBool
aDoDrawFullBorder);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD SetPreferredSize(PRInt32
aWidth, PRInt32 aHeight);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD GetPreferredSize(PRInt32&amp;
aWidth, PRInt32&amp; aHeight);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD SetWrapping(PRBool
aDoWrap);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD GetWrapping(PRBool
&amp; aDoWrap);</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp; NS_IMETHOD GetPreferredConstrainedSize(PRInt32&amp;
aSuggestedWidth, PRInt32&amp; aSuggestedHeight,PRInt32&amp; aWidth,PRInt32&amp;
aHeight);</font></tt>
<p><tt><font color="#000099">}</font></tt>
<p><tt><font color="#000099">class nsIDOMXUIImageButton : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<p><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetBounds(const nsRect&amp;
aBounds);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; GetLabel(nsString&amp;);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetLabel(const nsString&amp;
aString);</font></tt>
<p><tt><font color="#006600">&nbsp; // XXX: These should be expressed through
the CSS style instead. With a combination</font></tt>
<br><tt><font color="#006600">&nbsp; // of states and psedudo classes in
the style systems make this work.</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; GetHighlightColor(nscolor
&amp;aColor);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetHighlightColor(const
nscolor &amp;aColor);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; GetShadowColor(nscolor
&amp;aColor);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetShadowColor(const
nscolor &amp;aColor);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetImageURLs(const
nsString&amp; aUpURL,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const nsString&amp; aPressedURL,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const nsString&amp; aDisabledURL,</font></tt>
<br><tt><font color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const nsString&amp; aRollOverURL);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; GetRollOverDesc(nsString&amp;
aString);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetRollOverDesc(const
nsString&amp; aString);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetShowBorder(PRBool
aState);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetShowButtonBorder(PRBool
aState);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetBorderWidth(PRInt32
aWidth);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetBorderOffset(PRInt32
aWidth);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetShowText(PRBool
aState);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetShowImage(PRBool
aState);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetAlwaysShowBorder(PRBool
aState);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetImageDimensions(const
PRInt32 &amp; aWidth, const PRInt32 &amp; aHeight);</font></tt>
<br><tt><font color="#000099">&nbsp; </font><font color="#006600">// Alignment
Methods</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetImageVerticalAlignment(nsButtonVerticalAligment
aAlign);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetImageHorizontalAlignment(nsButtonHorizontalAligment
aAlign);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetTextVerticalAlignment(nsButtonVerticalAligment
aAlign);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetTextHorizontalAlignment(nsButtonHorizontalAligment
aAlign);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; GetPreferredSize(PRInt32&amp;
aWidth, PRInt32&amp; aHeight);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; SetPreferredSize(PRInt32
aWidth, PRInt32 aHeight);</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp; Enable(PRBool aState);</font></tt>
<br><tt><font color="#000099">}</font></tt>
<p><tt><font color="#000099">class nsIDOMXUIMenubar : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD GetElements(nsIDOMHTMLCollection**
aElements) = 0;</font></tt>
<br><tt><font color="#000099">}</font></tt>
<p><tt><font color="#000099">class nsIDOMXUIMenu : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD GetElements(nsIDOMHTMLCollection**
aElements) = 0;</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD SetLabel(nsString &amp;aText)
= 0;</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD GetLabel(nsString &amp;aText)
= 0;</font></tt>
<br><tt><font color="#000099">}</font></tt>
<p><tt><font color="#000099">class nsIDOMXUIMenuItem : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD SetLabel(nsString &amp;aText)
= 0;</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD GetLabel(nsString &amp;aText)
= 0;</font></tt>
<br><tt><font color="#000099">}</font></tt>
<br>&nbsp;
<p><tt><font color="#000099">class nsIDOMXUIPopupMenu : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD SetLabel(nsString &amp;aText)
= 0;</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD GetLabel(nsString &amp;aText)
= 0;</font></tt>
<br><tt><font color="#000099">}</font></tt>
<br>&nbsp;
<p><tt><font color="#000099">class nsIDOMXUITreeView : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#000099">&nbsp; NS_IMETHOD&nbsp;&nbsp;&nbsp; GetElements(nsIDOMHTMLCollection**
aElements) = 0;</font></tt>
<br><tt><font color="#000099">}</font></tt>
<p><tt><font color="#000099">class nsIDOMXUIListView : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#000099">}</font></tt>
<p><tt><font color="#000099">class nsIDOMXUIHtmlArea : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#000099">}</font></tt>
<p><tt><font color="#000099">class nsIDOMXUISplitter : public nsIDOMHTMLElement</font></tt>
<br><tt><font color="#000099">{</font></tt>
<br><tt><font color="#000099">}</font></tt>
<br>&nbsp;</td>
</tr>
</table>

<table COLS=1 WIDTH="80%" BGCOLOR="#FFFFCC" >
<tr>
<td><a NAME="XPFE Roadmap"></a><b>XPFE Roadmap</b></td>
</tr>
</table>

<table WIDTH="80%" >
<tr>
<td>The first release of XPFE will enable developers to create applications
as described in the section above. All events generated from the GUI will
be passed to the application specific code for processing. The GUI code
will then have to determine what action to take based on what widget was
clicked on or manipulated (See figure #7).
<center>
<p><img SRC="figure7.gif" height=292 width=460>
<br>Figure #7 - Raw Dispatch of GUI Events</center>

<p><b>JavaScript and XPFE</b>
<p>The second revision of the XPFE will enable the use of JavaScript and
JavaScript event handlers. The JavaScript event handlers by themselves
have considerable utility by enabling a higher level event processing.
When using JavaScript event handlers, methods within the C++ application
specific code can be called directly from the GUI. The event handlers eliminate
the need for "switching" off of button IDs.
<p>To enable JS event handlers, the C++ application specific code must
implement a JavaScript interface to expose any methods that will be servicing
GUI events. These exposed methods can then be referred to directly by the
GUI described in the HTML/XML. The callback code is still written in C++
but the low-level event dispatch is eliminated.
<p>It may be desirable to code some or all of the application specific
code in JavaScript. This would enable both the description of the visual
representation and the application specific "glue" code to be dynamic and
downloadable. To enable this, all components participating in the application
must provide access from JavaScript; hat means that each higher level interface
must be also be "wrapped" for use from JavaScript. Figure #8 shows how
an application may use both C++ code and JavaScript code.&nbsp;
<center>
<p><img SRC="figure8.gif" height=334 width=505>
<p>Figure #8 - Mixing JavaScript and C++ Application Specific Code</center>

<p>For example, in a browser UI the "Back" and "Forward" buttons may be
"wired" directly to the WebWidget's JavaScript event handlers. Then a "Add
Bookmark" menu selection may call a JavaScript event handler in the application
specific code for adding the bookmark directly though C++.
<p>A more powerful example of how JavaScript could be used as "glue" code,
is by having it directly augment the UI. For example, a user browsers a
web page that contains JavaScript for the loading of the document. This
piece of JavaScript uses the JS interface to XPFE to add a new button to
a toolbar. When the document is unloaded a small piece of JavaScript will
then remove an UI elements that it added.
<p><b><i>Note</i></b>: That when we allow emedded JavaScript to alter the
UI for a given application it is important to realize this implies a GUI
security manager that will grant or deney access to different parts of
the UI.
<p><b>Full JavaScript</b>
<br>Figure #9 shows how the entire application can be written in JavaScript.
<center><img SRC="figure9.gif" height=330 width=532>
<br>Figure #9 - Full JavaScript</center>

<p>&nbsp;</td>
</tr>
</table>

<br>&nbsp;
<table COLS=1 WIDTH="80%" BGCOLOR="#FFFFCC" >
<tr>
<td><a NAME="Dependencies"></a><b>Dependencies</b></td>
</tr>
</table>

<ul>
<li>
XML Parser</li>

<li>
XML Content Sink</li>

<li>
HT/RDF</li>

<li>
I10N</li>

<li>
Raptor Layout</li>

<li>
JavaScript</li>

<li>
GFX, NSPR, Widget</li>

<li>
Windows95, NT - Win32 API (Note: it is not dependent on MFC)</li>

<li>
Mac - MacOS</li>

<li>
Unix or Linux - XLIB X11R5 and MOTIF 1.2.</li>

<li>
Other OS's/windowing systems.</li>
</ul>

<br>&nbsp;




<P><BR>
</TD>


<TD VALIGN=TOP ALIGN=RIGHT><IMG ALT=""
SRC="../images/curve3.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#000000" VALIGN=TOP><IMG ALT=""
SRC="../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

</TR>
<TR>


<TD BGCOLOR="#000000" VALIGN=BOTTOM ALIGN=RIGHT><IMG ALT=""
SRC="../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#DDDDDD" VALIGN=BOTTOM><IMG ALT=""
SRC="../images/curve2.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#DDDDDD" VALIGN=BOTTOM ALIGN=RIGHT><IMG ALT=""
SRC="../images/curve4.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#000000" VALIGN=BOTTOM><IMG ALT=""
SRC="../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD VALIGN=BOTTOM><IMG ALT=""
SRC="../images/curve2.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>


<TD VALIGN=BOTTOM ALIGN=RIGHT><IMG ALT=""
SRC="../images/curve4.gif"
WIDTH=16 HEIGHT=16 HSPACE=0 VSPACE=0></TD>

<TD BGCOLOR="#000000" VALIGN=BOTTOM ALIGN=RIGHT><IMG ALT=""
SRC="../images/bit.gif"
WIDTH=4 HEIGHT=16 HSPACE=0 VSPACE=0></TD>
</TR>

<TR>

<TD BGCOLOR="#000000" COLSPAN=6><BR></TD>

<TD BGCOLOR="#000000" VALIGN=TOP>

<FONT COLOR="#AAAAAA" SIZE="-1">
Copyright &copy; 1998 The Mozilla Organization.
</FONT>
</FONT>
</TD>

<TD BGCOLOR="#000000" COLSPAN=2><BR></TD>
</TR>

</TABLE>
<P>
</BODY>
</HTML>
