<HTML>
<HEAD>
   <META NAME="Author" CONTENT="Wan-Teh Chang">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; I; IRIX 6.2 IP22) [Netscape]">
   <TITLE>Using IO Timeout and Interrupt on NT</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<H1>
Using IO Timeout and Interrupt on NT</H1>

<ADDRESS>
Last updated 9/22/97</ADDRESS>


<P>This technical memo is a cautionary note on using NSPR's IO timeout
and interrupt on Windows NT 3.51 and 4.0.  Due to a limitation of
the present implementation of NSPR IO on NT, programs must follow the following
guideline:
<UL>If a thread calls an NSPR IO function on a file descriptor and the
IO function fails with <TT>PR_IO_TIMEOUT_ERROR</TT> or <TT>PR_PENDING_INTERRUPT_ERROR</TT>,
the file descriptor must be closed before the thread exits.</UL>
In this memo we explain the  problem this guideline is trying to work
around and discuss its limitations.
<H2>
NSPR IO on NT</H2>
The IO model of NSPR 2.0 is synchronous and blocking.  A thread calling
an IO function is blocked until the IO operation finishes, either due to
a successful IO completion or an error.  If the IO operation cannot
complete before the specified timeout, the IO function returns with <TT>PR_IO_TIMEOUT_ERROR</TT>.
If the thread gets interrupted by another thread's <TT>PR_Interrupt()</TT>
call, the IO function returns with <TT>PR_PENDING_INTERRUPT_ERROR</TT>.

<P>On Windows NT, NSPR IO is implemented using NT's <I>overlapped</I> (also
called <I>asynchronous</I>) <I>IO</I>.  When a thread calls an IO
function, the thread issues an overlapped IO request using the overlapped
buffer in its <TT>PRThread</TT> structure. Then the thread is put to sleep.
In the meantime, there are dedicated internal threads (called the <I>idle
threads</I>) monitoring the IO completion port for completed IO requests.
If a completed IO request appears at the IO completion port, an idle thread
fetches it and wakes up the thread that issued the IO request earlier.
This is the normal way the thread is awakened.
<H2>
IO Timeout and Interrupt</H2>
However, NSPR may wake up the thread in two other situations:
<LI>
if the overlapped IO request is not completed before the specified timeout.
(Note that we can't specify timeout on overlapped IO requests, so the timeouts
are all handled at the nspr level.)  In this case, the error is <TT>PR_IO_TIMEOUT_ERROR</TT>.</LI>

<LI>
if the thread gets interrupted by another thread's <TT>PR_Interrupt()</TT>
call.  In this case, the error is <TT>PR_PENDING_INTERRUPT_ERROR</TT>.</LI>


<P>These two errors are generated by the NSPR layer, so the OS is oblivious
of what is going on and  the overlapped IO request is still in progress.
The OS still has a pointer to the overlapped buffer in the thread's <TT>PRThread</TT>
structure.  If the thread subsequently exists and its <TT>PRThread</TT>
structure gets deleted, the pointer to the overlapped buffer will be pointing
to freed memory. This is problematic.
<H2>
Canceling Overlapped IO by Closing the File Descriptor</H2>
Therefore, we  need to cancel the outstanding overlapped IO request
before the thread exits.  NT's <TT>CancelIo()</TT> function would
be ideal for this purpose.  Unfortunately, <TT>CancelIo()</TT> is
not available on NT 3.51.  So we can't go this route as long as we
are supporting NT 3.51.

<P>The only reliable way to cancel outstanding overlapped IO request that
works on both NT 3.51 and 4.0 is to close the file descriptor, hence the
rule of thumb stated at the beginning of this memo.
<H2>
Limitations</H2>
This seemingly harsh way to force the completion of outstanding overlapped
IO request has the following limitations:
<LI>
It is difficult for threads to shared a file descriptor.  For example,
suppose thread A and thread B call <TT>PR_Accept()</TT> on the same socket,
and they time out at the same time.  Following the rule of thumb,
both threads would close the socket.  The first <TT>PR_Close()</TT>
would succeed, but the second <TT>PR_Close()</TT> would be freeing freed
memory.  A solution that may work is to use a lock to ensure only
one thread can be using that socket at all times.</LI>

<LI>
Once there is a timeout or interrupt error, the file descriptor is no longer
usable.  Suppose the file descriptor is intended to be used for the
life time of the process, for example, the logging file, this is really
not acceptable.  A possible solution is to add a <TT>PR_DisableInterrupt()</TT>
function to turn off interrupts when accessing such file descriptors.</LI>


<P><B>Note</B>: A related known bug is that timeout and interrupt don't
work for <TT>PR_Connect()</TT> on NT.  This bug is due to a different
limitation in our NT implementation.
<H2>
Conclusions</H2>
As long as we need to support NT 3.51, we need to program under the guideline
that after an IO timeout or interrupt error, the thread must make sure
the file descriptor is closed before it exits.  Programs should also
take care in sharing file descriptors and using IO timeout or interrupt
on files that need to stay open throughout the process.

<P>When we stop supporting NT 3.51, we can look into using NT 4's <TT>CancelIo()</TT>
function to cancel outstanding overlapped IO requests when we get IO timeout
or interrupt errors.  If <TT>CancelIo()</TT> really works as advertised,
that should fundamentally solve this problem.

<P>If these limitations with IO timeout and interrupt are not acceptable
to the needs of your programs, you can consider using  the Win95 version
of NSPR.  The Win95 version runs without trouble on NT, but you would
lose the better performance provided by NT fibers and asynchronous IO.
<BR>
<DIV ALIGN=right><BR>
<BR>

<HR WIDTH="100%"></DIV>

<DIV ALIGN=right><I><FONT SIZE=-1>Last updated: Tue Mar 10 09:44:49 PST
1998</FONT></I></DIV>

<HR WIDTH="100%">
<CENTER>Copyright &copy; 1998 <A HREF="http://home.netscape.com/misc/contact_info.html">Netscape
Communications Corporation</A></CENTER>

</BODY>
</HTML>
