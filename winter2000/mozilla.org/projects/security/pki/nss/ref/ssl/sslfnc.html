<HTML>
<HEAD>
<TITLE>mozilla.org</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000"
LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000"
MARGINHEIGHT="0" MARGINWIDTH="0">

<MAP NAME="banner">
<AREA SHAPE=RECT COORDS="300,11,558,44" ALT="" HREF="http://www.mozilla.org/">
</MAP>

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#000000" VALIGN=TOP><IMG
SRC="../../../../../../images/mozilla-banner.gif"
ALT="" BORDER=0 USEMAP="#banner"
WIDTH="600" HEIGHT="58" VSPACE="0" HSPACE="0"></TD></TR></TABLE>

<TABLE BORDER="0" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">


<TR>


<TD VALIGN="TOP" >
<TABLE BORDER="0" ><TR><TD BGCOLOR="#000000" VALIGN="TOP">
<TABLE BORDER="0" CELLSPACING="3"><TR><TD BGCOLOR="#DDDDDD" VALIGN="TOP">
<TABLE CELLPADDING=0 CELLSPACING=3 BORDER=0>
<TR><TD NOWRAP COLSPAN=2><A HREF="../../../../../.././"><B> The Mozilla<BR>Organization</B></A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../mozorg.html"> At A Glance</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../feedback.html"> Feedback</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../get-involved.html"> Get Involved</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../community.html"> Newsgroups</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../MPL/"> License Terms</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="http://www.mozilla.org/newsbot/"> Newsbot</A></TD></TR>
<TR><TD NOWRAP VALIGN=TOP COLSPAN=3 - 1><B></B></TD></TR>
<TR><TD NOWRAP COLSPAN=2><A HREF="../../../../../../docs/"><B> Developer Docs</B></A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../roadmap.html"> Roadmap</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../projects/"> Projects</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../ports/"> Ports</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../owners.html"> Module Owners</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../hacking/"> Hacking</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../source.html"> Get the Source</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../build/"> Build It</A></TD></TR>
<TR><TD NOWRAP VALIGN=TOP COLSPAN=3 - 1><B></B></TD></TR>
<TR><TD NOWRAP COLSPAN=2><A HREF="../../../../../../quality/"><B> Testing</B></A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../binaries.html"> Download</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../bugs/"> Bugzilla</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="../../../../../../quality/bug-writing-guidelines.html"> Bug Writing</A></TD></TR>
<TR><TD NOWRAP VALIGN=TOP COLSPAN=3 - 1><B></B></TD></TR>
<TR><TD NOWRAP COLSPAN=2><A HREF="../../../../../../tools.html"><B> Tools</B></A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="http://lxr.mozilla.org/seamonkey/"> View Source</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="http://tinderbox.mozilla.org/showbuilds.cgi?tree=SeaMonkey"> Tree Status</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="http://cvs-mirror.mozilla.org/webtools/bonsai/cvsquery.cgi?treeid=default&amp;module=SeaMonkeyAll&amp;branch=HEAD&amp;branchtype=match&amp;dir=&amp;file=&amp;filetype=match&amp;who=&amp;whotype=match&amp;sortby=Date&amp;hours=2&amp;date=day&amp;mindate=&amp;maxdate=&amp;cvsroot=%2Fcvsroot"> New Checkins</A></TD></TR>
<TR><TD></TD><TD NOWRAP><A HREF="http://bugzilla.mozilla.org/"> Submit A Bug</A></TD></TR>
<TR><TD NOWRAP VALIGN=TOP COLSPAN=3 - 1><B></B></TD></TR>
<TR><TD NOWRAP COLSPAN=2><A HREF="../../../../../../faq.html"><B> FAQ</B></A></TD></TR>
<TR><TD NOWRAP COLSPAN=2><A HREF="http://www.mozilla.org/search.html"><B> Search</B></A></TD></TR>
</TABLE>
</TD></TR></TABLE>
</TD></TR></TABLE>
</TD>


<TD VALIGN="TOP">



<TITLE>SSL Functions
</TITLE>




<FONT SIZE=-1><A HREF="index.html">Table of Contents</A> | <A HREF="ssltyp.html">Previous</A>
 | <A HREF="sslcrt.html">Next</A>
 | <A HREF="bklast.html">Index</A>
</FONT><BR><BR>


<BR>
<HR>
<A NAME="1022819">
<P></A><CENTER><H2>Chapter 4<BR>
<A NAME="1047959">
SSL Functions</A></H2></CENTER>
<A NAME="1047960">
This chapter describes the core SSL functions.</A></P>
<A NAME="1047964">
<A HREF="sslfnc.html#1022864">SSL Initialization Functions</A><br><A HREF="sslfnc.html#1098841">SSL Export Policy Functions</A><br><A HREF="sslfnc.html#1163855">SSL Configuration Functions</A><br><A HREF="sslfnc.html#1127321">SSL Communication Functions</A><br><A HREF="sslfnc.html#1127893">SSL Functions Used by Callbacks</A><br><A HREF="sslfnc.html#1061582">SSL Handshake Functions</A><br><A HREF="sslfnc.html#1095840">NSS Shutdown Function</A></A></P>

<H2><A NAME="SSL Initialization Functions"></A>
<A NAME="1022864">
 SSL Initialization Functions
</A></H2><A NAME="1090069">
This section describes the initialization functions that are specific to SSL. For a complete list of NSS initialization functions, see <A HREF="sslintro.html#1027662">Initialization</A>.</A></P>
<A NAME="1116142">
Note that at least one of the functions listed in <A HREF="sslfnc.html#1098841">SSL Export Policy Functions</A> must also be called during NSS initialization.</A></P>
<A NAME="1090078">
<A HREF="sslfnc.html#1067601"><CODE>NSS_Init</CODE></A><br><A HREF="sslfnc.html#1068466"><CODE>SSL_EnableDefault</CODE></A><br><A HREF="sslfnc.html#1084747"><CODE>SSL_EnableCipher</CODE></A><br><A HREF="sslfnc.html#1138601"><CODE>SSL_ClearSessionCache</CODE></A><br><A HREF="sslfnc.html#1143851"><CODE>SSL_ConfigServerSessionIDCache</CODE></A><br><A HREF="sslfnc.html#1142625"><CODE>SSL_ConfigMPServerSIDCache</CODE></A><br><A HREF="sslfnc.html#1162055"><CODE>SSL_InheritMPServerSIDCache</CODE></A></A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1067601">
 NSS_Init
</A></H4>

<A NAME="1067602">
Sets up configuration files and performs other tasks required to run Network Security Services.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1067603">
 Syntax
</A></H5>

<PRE><A NAME="1067604">#include &lt;nss.h&gt; </A></PRE><PRE><A NAME="1067605">SECStatus NSS_Init(char *configdir);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1067606">
 Parameter
</A></H5>

<A NAME="1067612">
This function has the following parameter:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1067609">
<CODE>configdir</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1067611">
A pointer to a string containing the pathname of the directory where the Certificate, Key, and Security Module databases reside.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1067613">
 Returns
</A></H5>

<A NAME="1067614">
The function returns one of these value<VAR>s</VAR>:</A></P>
<ul><P><LI><A NAME="1067615">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<P><LI><A NAME="1067618">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" >PR_GetError<CODE></A></CODE> to retrieve the error code.</A></LI>
</ul><H5><A NAME="Head4;"></A>
<A NAME="1067619">
 Description
</A></H5>

<A NAME="1067620">
<CODE>NSS_Init</CODE> opens the <CODE>Cert</CODE><I>N</I><CODE>.db</CODE>, <CODE>Key</CODE><I>N</I><CODE>.db</CODE>, and <CODE>secmod.db</CODE> files (where <I>N</I> is a numeric digit) in the specified directory. <CODE>NSS_Init</CODE> is <I>not</I> idempotent, so call it only once. </A></P>
<A NAME="1067621">
Before calling <CODE>NSS_Init</CODE>, your program must call <CODE><A href="../../../../../../docs/refList/refNSPR/prinit.html#1018659" >PR_Init</A></CODE>.</A></P>
<A NAME="1107512">
The policy flags for all cipher suites are turned off by default, disallowing all cipher suites. Therefore, an application cannot use NSS to perform any cryptographic operations until after it enables appropriate cipher suites by calling one of the <A HREF="sslfnc.html#1098841">SSL Export Policy Functions</A>:</A></P>
<ul><P><LI><A NAME="1107624">
<A HREF="sslfnc.html#1100560"><CODE>NSS_SetDomesticPolicy</CODE></A>, <A HREF="sslfnc.html#1100285"><CODE>NSS_SetExportPolicy</CODE></A>, and <A HREF="sslfnc.html#1105952"><CODE>NSS_SetFrancePolicy</CODE></A> configure the cipher suites for domestic, international, and French versions of software products with encryption features.</A></LI>
<P><LI><A NAME="1107952">
<A HREF="sslfnc.html#1104647"><CODE>SSL_SetPolicy</CODE></A> sets policy flags for individual cipher suites, one at a time. This may be helpful if you have an export license that permits more or fewer capabilities than those allowed by the other export policy functions.</A></LI>
</ul>
<H4><A NAME="Head3;"></A>
<A NAME="1068466">
 SSL_EnableDefault
</A></H4>

<A NAME="1068467">
Changes a default value for all subsequently opened sockets as long as the current application program is running.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1068468">
 Syntax
</A></H5>

<PRE><A NAME="1068469">#include &lt;ssl.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1068470">SECStatus SSL_EnableDefault(int which, PRBool on);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1068471">
 Parameters
</A></H5>

<A NAME="1068489">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1068474">
<CODE>which</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1068476">
One of the following values (except as noted, the default is "off"):</A></P><ul></P><LI><A NAME="1068477">
<CODE>SSL_SECURITY</CODE> enables use of security protocol. On by default. <EM>WARNING</EM>: If you turn this option off, the session will not be an SSL session and will not have certificate-based authentication, tamper detection, or encryption.</A></P><LI><A NAME="1068478">
<CODE>SSL_REQUEST_CERTIFICATE</CODE> is a server option that requests a client to authenticate itself. Off by default.</A></P><LI><A NAME="1068479">
<CODE>SSL_REQUIRE_CERTIFICATE</CODE> is a server option that requires a client to authenticate itself (only if <CODE>SSL_REQUEST_CERTIFICATE</CODE> is also on). If client does not provide certificate, the connection terminates. Default state is a third state similar to on, that provides backward compatibility with older Netscape server products.</A></P><LI><A NAME="1068480">
<CODE>SSL_HANDSHAKE_AS_CLIENT</CODE> forces handshake as a client, with or without authentication. On by default.</A></P><LI><A NAME="1068481">
<CODE>SSL_HANDSHAKE_AS_SERVER</CODE> forces handshake as a server, with or without authentication. Off by default.</A></P><LI><A NAME="1068482">
<CODE>SSL_ENABLE_SSL3</CODE> enables the application to communicate with SSL v3. On by default. If you turn this option off, an attempt to establish a connection with a peer that only understands SSL v3 will fail.</A></P><LI><A NAME="1068483">
<CODE>SSL_ENABLE_SSL2</CODE> enables the application to communicate with SSL v2. On by default. If you turn this option off, an attempt to establish a connection with a peer that only understands SSL v2 will fail.</A></P><LI><A NAME="1068484">
<CODE>SSL_NO_CACHE</CODE> disallows use of the session cache. Off by default. If you turn this option on, this socket will be unable to resume a session begun by another socket. When this socket's session is finished, no other socket will be able to resume the session begun by this socket. </A></ul>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1068486">
<CODE>on</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1068488">
<CODE>PR_TRUE</CODE> turns option on; <CODE>PR_FALSE</CODE> turns option off.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1068490">
 Returns
</A></H5>

<A NAME="1068491">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1068492">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1068495">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1068496">
 Description
</A></H5>

<A NAME="1134111">
This function changes the default values for all subsequently opened sockets as long as the current application program is running. This function must be called once for each default value you want to change. To change a value in a socket that is already open, use <A HREF="sslfnc.html#1086543"><CODE>SSL_Enable</CODE></A>.</A></P>
<A NAME="1134096">
Keep the following in mind when deciding on the operating parameters you want to use with a particular socket:</A></P>
<ul><P><LI><A NAME="1068498">
The default values that you set with this function apply only to the current application session. If the application program is terminated and then restarted, any default values that were reset by this function revert to their original values.</A></LI>
<P><LI><A NAME="1079629">
Turning on <CODE>SSL_REQUIRE_CERTIFICATE</CODE> has no effect unless <CODE>SSL_REQUEST_CERTIFICATE </CODE>is also turned on. If you enable <CODE>SSL_REQUEST_CERTIFICATE</CODE>, then you should explicitly enable or disable <CODE>SSL_REQUIRE_CERTIFICATE</CODE> rather than allowing it to default. Enabling the <CODE>SSL_REQUIRE_CERTIFICATE</CODE> option is not recommended. If the client has no certificate and this option is enabled, the client's connection terminates with an error. The user is likely to think something is wrong with either the client or the server, and is unlikely to realize that the problem is the lack of a certificate. It is better to allow the SSL handshake to complete and then return an error message to the client that informs the user of the need for a certificate.</A></LI>
<P><LI><A NAME="1068500">
If both <CODE>SSL_HANDSHAKE_AS_CLIENT</CODE> and <CODE>SSL_HANDSHAKE_AS_SERVER</CODE> are turned off, then whether the socket is that of a client or that of a server depends on how you open the socket. If you use <A href="../../../../../../docs/refList/refNSPR/priofnc.html#439145" ><CODE>PR_Accept</A></CODE>, the socket is that of a server. If you use <A href="../../../../../../docs/refList/refNSPR/priofnc.html#436330" ><CODE>PR_Connect</A></CODE>, the socket is that of a client. See also <A HREF="sslfnc.html#1087163"><CODE>SSL_ConfigSecureServer</CODE></A>.</A></LI>
<P><LI><A NAME="1068505">
<CODE>SSL_HANDSHAKE_AS_CLIENT</CODE> and <CODE>SSL_HANDSHAKE_AS_SERVER</CODE> cannot both be set to on simultaneously. If you attempt to turn one option on when the other is already on, <CODE>SSL_EnableDefault</CODE> fails, returning with the error code set to <CODE>SEC_ERROR_INVALID_ARGS</CODE>. </A></LI>
</ul>
<H4><A NAME="Head3;"></A>
<A NAME="1084747">
 SSL_EnableCipher
</A></H4>

<A NAME="1084748">
Enables or disables cipher suites (subject to which cipher suites are permitted or disallowed by previous calls to one or more of the <A HREF="sslfnc.html#1098841">SSL Export Policy Functions</A>). This function must be called once for each cipher you want to enable or disable. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1084749">
 Syntax
</A></H5>

<PRE><A NAME="1084750">#include &lt;ssl.h&gt;<br>#include &lt;sslproto.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1084751">SECStatus SSL_EnableCipher(long which, PRBool enabled);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1084752">
 Parameters
</A></H5>

<A NAME="1084766">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1084755">
<CODE>which</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1084757">
One of the following values for SSL2 (all are enabled by default):</A></P><P><A NAME="1084758">
<CODE>SSL_EN_RC4_128_WITH_MD5<br>SSL_EN_RC4_128_EXPORT40_WITH_MD5<br>SSL_EN_RC2_128_CBC_WITH_MD5<br>SSL_EN_RC2_128_CBC_EXPORT40_WITH_MD5<br>SSL_EN_DES_64_CBC_WITH_MD5<br>SSL_EN_DES_192_EDE3_CBC_WITH_MD5</CODE></A></P><P><A NAME="1084759">
</A></P><P><A NAME="1084760">
Or one of the following values for SSL3 (unless indicated otherwise, all are enabled by default):</A></P><P><A NAME="1093245">
<CODE>SSL_RSA_WITH_NULL_MD5</CODE> (not enabled by default)<br><CODE>SSL_RSA_EXPORT_WITH_RC4_40_MD5<br>SSL_RSA_WITH_RC4_128_MD5<br>SSL_RSA_WITH_RC4_128_SHA<br>SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5<br>SSL_RSA_EXPORT_WITH_DES40_CBC_SHA<br>SSL_RSA_WITH_DES_CBC_SHA<br>SSL_RSA_WITH_3DES_EDE_CBC_SHA<br>SSL_FORTEZZA_DMS_WITH_NULL_SHA</CODE> (not enabled by default)<CODE> <br>SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA<br>SSL_FORTEZZA_DMS_WITH_RC4_128_SHA<br>SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA<br>SSL_RSA_FIPS_WITH_DES_CBC_SHA</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1084763">
<CODE>enabled</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1084765">
If nonzero, the specified cipher is enabled. If zero, the cipher is disabled.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1084767">
 Returns
</A></H5>

<A NAME="1084768">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1084769">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1116247">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1116248">
 Description
</A></H5>

<A NAME="1116249">
The <CODE>SSL_EnableCipher</CODE> function enables or disables individual cipher suites globally. You typically call this in response to changes in user-controlled settings. You cannot enable or disable cipher suites for an individual socket. You must call this function once for each cipher you want to enable or disable.</A></P>
<A NAME="1124282">
By default, all cipher suites except <CODE>SSL_RSA_WITH_NULL_MD5</CODE> and <CODE>SSL_FORTEZZA_DMS_WITH_NULL_SHA </CODE>are enabled. However, this does not necessarily mean that they are all permitted. The <CODE>SSL_EnableCipher</CODE> function cannot override cipher suite policy settings that are not permitted; see <A HREF="sslfnc.html#1098841">SSL Export Policy Functions</A> for details. Your application must call one of the export policy functions before it can perform any cryptographic operations.</A></P>
<A NAME="1084775">
In this release, the three <CODE>SSL_FORTEZZA_</CODE> cipher suites cannot be enabled unless there is a PKCS #11 module available with a FORTEZZA-enabled token. </A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1138601">
 SSL_ClearSessionCache
</A></H4>

<A NAME="1138602">
Empties the SSL client session ID cache.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1138603">
 Syntax
</A></H5>

<PRE><A NAME="1138604">#include &lt;ssl.h&gt; </A></PRE><PRE><A NAME="1138605">void SSL_ClearSessionCache(void);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1138606">
 Description
</A></H5>

<A NAME="1138609">
You must call <CODE>SSL_ClearSessionCache</CODE> after you use one of the <A HREF="sslfnc.html#1098841">SSL Export Policy Functions</A> to change cipher suite policy settings or use <A HREF="sslfnc.html#1084747"><CODE>SSL_EnableCipher</CODE></A> to enable or disable any cipher suite. Otherwise, the old settings remain in the session cache and will be used instead of the new settings.</A></P>
<A NAME="1141738">
This function clears only the client cache. The client cache is not configurable. It is located in RAM (not on disk), and has the following characteristics:</A></P>
<ul><P><LI><A NAME="1140229">
maximum number of entries: unlimited</A></LI>
<P><LI><A NAME="1140230">
SSL 2.0 timeout value: 100 seconds</A></LI>
<P><LI><A NAME="1143849">
SSL 3.0 timeout value: 24 hours</A></LI>
</ul>
<H4><A NAME="Head3;"></A>
<A NAME="1143851">
 SSL_ConfigServerSessionIDCache
</A></H4>

<A NAME="1143852">
Sets up parameters for and opens the server session cache for a single-process application.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1085382">
 Syntax
</A></H5>

<PRE><A NAME="1085383">#include &lt;ssl.h&gt;<br>#include &lt;prtypes.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1085384">SECStatus SSL_ConfigServerSessionIDCache(<br>&nbsp;&nbsp;&nbsp;int maxCacheEntries,<br>&nbsp;&nbsp;&nbsp;PRUint32 timeout,<br>&nbsp;&nbsp;&nbsp;PRUint32 ssl3_timeout,<br>&nbsp;&nbsp;&nbsp;const char *directory); </A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1085385">
 Parameters
</A></H5>

<A NAME="1085386">
This function has the parameters listed below. <TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1085389">
<CODE>maxCacheEntries</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1085391">
The maximum number of entries in the cache. If a <CODE>NULL</CODE> value is passed, the server default value of 10,000 is used. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1085393">
<CODE>timeout</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1085395">
The lifetime in seconds of an SSL2 session. The minimum timeout value is 5 seconds and the maximum is 24 hours. Values outside this range are replaced by the server default value of 100 seconds.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1085397">
<CODE>ssl3_timeout</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1085399">
The lifetime in seconds of an SSL3 session. The minimum timeout value is 5 seconds and the maximum is 24 hours. Values outside this range are replaced by the server default value of 24 hours.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1085401">
<CODE>directory</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1085403">
A pointer to a string specifying the pathname of the directory that will contain the session cache. If a <CODE>NULL</CODE> value is passed, the server default value is used: <CODE>/tmp</CODE> (Unix) or <CODE>\\temp</CODE> (NT).</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1085404">
 Returns
</A></H5>

<A NAME="1085405">
The function returns one of these value<VAR>s</VAR>:</A></P>
<ul><P><LI><A NAME="1085406">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1085409">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1085410">
 Description
</A></H5>

<A NAME="1085412">
If you are writing an application that will use SSL sockets that handshake as a 
server, you must call <CODE>SSL_ConfigServerSessionIDCach</CODE> to configure 
additional session caches for <EM>server</EM> sessions. If your server application uses 
multiple processes (instead of or in addition to multiple threads), use 
<A HREF="sslfnc.html#1142625"><CODE>SSL_ConfigMPServerSIDCache</CODE></A> instead. You must use one of these functions 
to create a server cache.
</A>
</BLOCKQUOTE>
<A NAME="1142070">
This function creates two caches: the <I>server session ID cache</I> (also called the server session cache, or server cache), and the <I>client-auth certificate cache</I> (also called the client cert cache, or client auth cache). Both caches are used only for sessions where the program handshakes as a server. The client-auth certificate cache is used to remember the certificates previously presented by clients for client certificate authentication. </A></P>
<A NAME="1085416">
Passing a <CODE>NULL</CODE> value or a value that is out of range for any of the parameters 
causes the server default value to be used in the server cache. The values that 
you pass affect only the server cache, not the client cache.
</A>
</BLOCKQUOTE>

<H3><A NAME="Head2;"></A>
<A NAME="1154189">
 Initializing Multi-Processing with a Shared SSL Server Cache 
</A></H3>

<A NAME="1154193">
To start a multi-processing application, the initial parent process calls <A HREF="sslfnc.html#1142625"><CODE>SSL_ConfigMPServerSIDCache</CODE></A>, and then creates child processes, by one of these methods: </A></P>
<ul><P><LI><A NAME="1154194">
Call <CODE>fork()</CODE> and then <CODE>exec()</CODE> (Unix) </A></LI>
<P><LI><A NAME="1154195">
Call <CODE>CreateProcess()</CODE> (Win32)</A></LI>
<P><LI><A NAME="1154196">
Call <CODE>PR_CreateProcess()</CODE> (both Unix and Win32)</A></LI>
</ul><A NAME="1154197">
It is essential that the parent allow the child to inherit the file descriptors. WIN32's <CODE>CreateProcess()</CODE> takes an argument that tells it whether or not to permit files to be inherited; this argument must be <CODE>TRUE</CODE>.  </A></P>
<A NAME="1154198">
When a new child that has been created by either <CODE>CreateProcess()</CODE> or <CODE>exec()</CODE> begins, it may have inherited file descriptors (FDs), but not the parent's memory. Therefore, to find out what FDs it has inherited, it must be told about them. To that end, the function <A HREF="sslfnc.html#1142625"><CODE>SSL_ConfigMPServerSIDCache</CODE></A> sets an environment variable named <CODE>SSL_INHERITANCE</CODE>. The value of the variable is a printable ASCII string, containing all the information needed to set up and use the inherited FDs.  </A></P>
<A NAME="1154202">
There are two ways to transfer the content of <CODE>SSL_INHERITANCE</CODE> from parent to child:</A></P>
<ul><P><LI><A NAME="1154203">
The child inherits the parent's environment, which must include the <CODE>SSL_INHERITANCE</CODE> variable. For the child to inherit the parent's environment you must set a specific argument to <CODE>CreateProcess()</CODE> or <CODE>PR_CreateProcess()</CODE>.  </A></LI>
<P><LI><A NAME="1154204">
The parent transmits the content of <CODE>SSL_INHERITANCE</CODE> to the child by some other means, such as on the command line, or in another file or pipe. </A></LI>
</ul><A NAME="1160413">
In either case, the child must call <A HREF="sslfnc.html#1162055"><CODE>SSL_InheritMPServerSIDCache</CODE></A> to complete the inheritance of the shared cache FDs/handles. </A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1142625">
 SSL_ConfigMPServerSIDCache
</A></H4>

<A NAME="1142626">
Sets up parameters for and opens the server session cache for a multi-process application.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1142627">
 Syntax
</A></H5>

<PRE><A NAME="1142628">#include &lt;ssl.h&gt;<br>#include &lt;prtypes.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1142629">SECStatus SSL_ConfigMPServerSIDCache(<br>&nbsp;&nbsp;&nbsp;int maxCacheEntries,<br>&nbsp;&nbsp;&nbsp;PRUint32 timeout,<br>&nbsp;&nbsp;&nbsp;PRUint32 ssl3_timeout,<br>&nbsp;&nbsp;&nbsp;const char *directory); </A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1142630">
 Parameters
</A></H5>

<A NAME="1142648">
This function has the parameters listed below. <TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1142633">
<CODE>maxCacheEntries</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1142635">
The maximum number of entries in the cache. If a <CODE>NULL</CODE> value is passed, the server default value of 10,000 is used. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1142637">
<CODE>timeout</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1142639">
The lifetime in seconds of an SSL2 session. The minimum timeout value is 5 seconds and the maximum is 24 hours. Values outside this range are replaced by the server default value of 100 seconds.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1142641">
<CODE>ssl3_timeout</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1142643">
The lifetime in seconds of an SSL3 session. The minimum timeout value is 5 seconds and the maximum is 24 hours. Values outside this range are replaced by the server default value of 24 hours.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1142645">
<CODE>directory</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1142647">
A pointer to a string specifying the pathname of the directory that will contain the session cache. If a <CODE>NULL</CODE> value is passed, the server default value is used: <CODE>/tmp</CODE> (Unix) or <CODE>\\temp</CODE> (NT).</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1142649">
 Returns
</A></H5>

<A NAME="1142650">
The function returns one of these value<VAR>s</VAR>:</A></P>
<ul><P><LI><A NAME="1142651">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1142654">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678"><CODE>PR_GetError</A></CODE> to obtain error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1142655">
 Description
</A></H5>

<A NAME="1142656">
This function is identical to <A HREF="sslfnc.html#1143851"><CODE>SSL_ConfigServerSessionIDCache</CODE></A>, except that it is for use with applications that use multiple processes. You must use one or the other of these functions to create a server cache, not both.</A></P>
<A NAME="1148381">
If your application will use multiple processes (instead of, or in addition to, multiple threads), and all of the processes appear to be on the same server (same IP address and port number), then those processes must share a common SSL session cache. The common parent of all the processes must call this function to create the cache before creating the other processes.</A></P>
<A NAME="1143091">
An application uses multiple processes <I>only</I> if it uses the Unix function <CODE>fork</CODE>, or the Win32 function <CODE>CreateProcess</CODE>. This is not the same as using multiple threads or multiple processors. Note that an SSL server that uses Fortezza hardware devices is limited to a single process. It can use multiple threads, and thereby make use of multiple processors, but this must all be done from a single process.</A></P>
<A NAME="1142657">
This function creates two caches: the <I>server session ID cache</I> (also called the server session cache, or server cache), and the <I>client-auth certificate cache</I> (also called the client cert cache, or client auth cache). Both caches are used only for sessions where the program handshakes as a server. The client-auth certificate cache is used to remember the certificates previously presented by clients for client certificate authentication. </A></P>
<A NAME="1142659">
Passing a <CODE>NULL</CODE> value or a value that is out of range for any of the parameters 
causes the server default value to be used in the server cache. The values that 
you pass affect only the server cache, not the client cache.
</A>
</BLOCKQUOTE>
<A NAME="1163184">
Before the cache can be used in the child process, the child process must complete its initialization using <A HREF="sslfnc.html#1162055"><CODE>SSL_InheritMPServerSIDCache</CODE></A>.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1162055">
 SSL_InheritMPServerSIDCache
</A></H4>

<A NAME="1162056">
Ensures the inheritance of file descriptors to a child process.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1162057">
 Syntax
</A></H5>

<PRE><A NAME="1162383">SECStatus SSL_InheritMPServerSIDCache (const char *envString);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1162398">
 Parameters
</A></H5>

<A NAME="1162610">
This function has the following parameter: <TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1162595">
<CODE>envString</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1162597">
A pointer to the location of the inheritance information. The value depends on how you are passing the information.</A></P><P><A NAME="1162933">
</A></P><P><A NAME="1162935">
If a <CODE>NULL</CODE> value is passed, the function looks for the <CODE>SSL_INHERITANCE</CODE> variable that has been inherited as part of the child's environment. </A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1162413">
 Returns
</A></H5>

<A NAME="1162414">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1162415">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1162418">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1162419">
 Description
</A></H5>

<A NAME="1162038">
This function completes the inheritance of file descriptors from a parent to a child process. After the child process is created, it must call this function to complete its initialization.</A></P>
<A NAME="1163084">
The value of the <CODE>envString</CODE> argument depends on which of the two possible inheritance schemes you have used. (See <A HREF="sslfnc.html#1154189">Initializing Multi-Processing with a Shared SSL Server Cache</A>.)</A></P>
<ul><P><LI><A NAME="1163085">
If the <CODE>SSL_INHERITANCE</CODE> variable has been inherited as part of the child's environment, the child must pass a <CODE>NULL</CODE> pointer as the <CODE>envString</CODE> argument. This causes the function to look in the environment for the variable.</A></LI>
<P><LI><A NAME="1163086">
If the parent has transmitted the value of the <CODE>SSL_INHERITANCE</CODE> variable to the child by some other means, the child must pass a pointer to that string as the <CODE>envString</CODE> argument to complete the inheritance.</A></LI>
</ul><A NAME="1163090">
When this function returns <CODE>SECSuccess</CODE>, the server cache is ready to be used by the SSL code.</A></P>

<H2><A NAME="SSL Export Policy Functions"></A>
<A NAME="1098841">
 SSL Export Policy Functions
</A></H2><BLOCKQUOTE><A NAME="1100817"><B>Important
 </B></A>
<A NAME="1163755">
This section has not yet been updated to reflect the new export regulations. 
Therefore, the information in this section is out of date. It will be updated when 
the source code for NSS is posted to Mozilla.
</A>
</BLOCKQUOTE>
<A NAME="1163748">
The SSL export policy functions determine which cipher suites are <I>permitted</I> for use in an SSL session. They do not determine which cipher suites are actually <I>enabled</I>--that is, turned on and ready to use. To enable or disable a permitted cipher suite, use <A HREF="sslfnc.html#1084747"><CODE>SSL_EnableCipher</CODE></A>; but bear in mind that <A HREF="sslfnc.html#1084747"><CODE>SSL_EnableCipher</CODE></A> can't enable any cipher suite that is not explicitly permitted as a result of a call to one of the export policy functions.</A></P>
<A NAME="1117995">
By default, none of the cipher suites supported by SSL are permitted. The functions <A HREF="sslfnc.html#1100560"><CODE>NSS_SetDomesticPolicy</CODE></A>, <A HREF="sslfnc.html#1100285"><CODE>NSS_SetExportPolicy</CODE></A>, and <A HREF="sslfnc.html#1105952"><CODE>NSS_SetFrancePolicy</CODE></A> permit the use of approved cipher suites for domestic, international, and French versions, respectively, of software products with encryption features. The policy settings permitted by these functions conform with current U.S. export regulations (as understood by Netscape) and French import regulations governing such products. </A></P>
<A NAME="1103578">
Under some circumstances, you may be required to abide by the terms of an export license that permits more or fewer capabilities than those allowed by these three functions. In such cases, use <A HREF="sslfnc.html#1104647"><CODE>SSL_SetPolicy</CODE></A> to explicitly enable those cipher suites you may legally export.</A></P>
<A NAME="1122340">
Applications must call one of the export policy functions before attempting to perform any cryptographic operations. </A></P>
<A NAME="1122343">
For descriptions of cipher suites supported by SSL, see <A HREF="../ssl/index.htm" TARGET="_top">Introduction to SSL</A>.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1100560">
 NSS_SetDomesticPolicy
</A></H4>

<A NAME="1100273">
Configures cipher suites to conform with current U.S. export regulations related to domestic software products with encryption features. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1100275">
 Syntax
</A></H5>

<PRE><A NAME="1100276">#include &lt;nss.h&gt;</A></PRE><PRE><A NAME="1100639">extern SECStatus NSS_SetDomesticPolicy(void);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1100277">
 Returns
</A></H5>

<A NAME="1100702">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1100731">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1100734">
If unsuccessful, returns <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1100278">
 Description
</A></H5>

<A NAME="1101005">
<CODE>NSS_SetDomesticPolicy</CODE> configures all the cipher suites listed under <A HREF="sslfnc.html#1104647"><CODE>SSL_SetPolicy</CODE></A> for software that is <I>not</I> intended for export, and is thus not required to conform with U.S. export regulations related to domestic software products with encryption features. After calling this function, all cipher suites listed are permitted (but not necessarily enabled; see <A HREF="sslfnc.html#1098841">SSL Export Policy Functions</A>) for the calling application. </A></P>
<A NAME="1118130">
When an SSL connection is established, SSL permits the use of the strongest cipher suites that are both permitted and enabled for the software on both ends of the connection. For example, if a client that has called <CODE>NSS_SetDomesticPolicy</CODE> establishes an SSL connection with a server for which some cipher suites are either not permitted or not enabled (such as an international version of Netscape server software), SSL uses the strongest cipher suites supported by the server that are also supported by the client. </A></P>
<A NAME="1101459">
Under some circumstances, you may be required to abide by the terms of an export license that permits more or fewer capabilities than those allowed by <CODE>NSS_SetDomesticPolicy</CODE>. In that case, first call <A HREF="sslfnc.html#1100560"><CODE>NSS_SetDomesticPolicy</CODE></A>, <A HREF="sslfnc.html#1100285"><CODE>NSS_SetExportPolicy</CODE></A>, or <A HREF="sslfnc.html#1105952"><CODE>NSS_SetFrancePolicy</CODE></A>, then call <A HREF="sslfnc.html#1104647"><CODE>SSL_SetPolicy</CODE></A> repeatedly to explicitly allow or disallow cipher suites until only those that you may legally export are permitted. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1122544">
 Important
</A></H5>

<A NAME="1122628">
If you call <CODE>NSS_SetDomesticPolicy</CODE> sometime after initialization to change 
cipher suite policy settings, you must also call <CODE>SSL_ClearSessionCache</CODE>. 
Otherwise, the old settings remain in the session cache and will be used instead 
of the new settings. 
</A>
</BLOCKQUOTE>

<H4><A NAME="Head3;"></A>
<A NAME="1100285">
 NSS_SetExportPolicy
</A></H4>

<A NAME="1101621">
Configures the SSL cipher suites to conform with current U.S. export regulations related to international software products with encryption features.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1101604">
 Syntax
</A></H5>

<PRE><A NAME="1109602">#include &lt;nss.h&gt;</A></PRE><PRE><A NAME="1100286">extern SECStatus NSS_SetExportPolicy(void);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1101655">
 Returns
</A></H5>

<A NAME="1101656">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1101657">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1101660">
If unsuccessful, returns <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1100287">
 Description
</A></H5>

<A NAME="1102307">
<CODE>NSS_SetExportPolicy</CODE> configures all the cipher suites listed under <A HREF="sslfnc.html#1104647"><CODE>SSL_SetPolicy</CODE></A> to conform with current U.S. export regulations related to international software products with encryption features (as Netscape understands them). Calling this function permits use of cipher suites listed below (but doesn't necessarily enable them; see <A HREF="sslfnc.html#1098841">SSL Export Policy Functions</A>). Policy for these suites is set to <CODE>SSL_ALLOWED</CODE> unless otherwise indicated. <CODE>SSL_RESTRICTED</CODE> means the suite can be used by clients only when they are communicating with domestic server software or with international server software that presents a Global ID certificate. For more details on policy settings, see <A HREF="sslfnc.html#1104647"><CODE>SSL_SetPolicy</CODE></A>.</A></P>
<A NAME="1102568">
For SSL 2.0:</A></P>
<ul><P><LI><A NAME="1102934">
<CODE>SSL_EN_RC4_128_EXPORT40_WITH_MD5</CODE></A></LI>
<P><LI><A NAME="1103038">
<CODE>SSL_EN_RC2_128_CBC_EXPORT40_WITH_MD5</CODE></A></LI>
</ul><A NAME="1102571">
For SSL 3.0:</A></P>
<ul><P><LI><A NAME="1119271">
<CODE>SSL_RSA_WITH_NULL_MD5</CODE></A></LI>
<P><LI><A NAME="1102519">
<CODE>SSL_RSA_WITH_RC4_128_MD5 (SSL_RESTRICTED)</CODE></A></LI>
<P><LI><A NAME="1118523">
<CODE>SSL_RSA_WITH_3DES_EDE_CBC_SHA (SSL_RESTRICTED)</CODE></A></LI>
<P><LI><A NAME="1105215">
<CODE>SSL_RSA_EXPORT_WITH_RC4_40_MD5</CODE></A></LI>
<P><LI><A NAME="1105216">
<CODE>SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5</CODE></A></LI>
</ul><A NAME="1100288">
Under some circumstances, you may be required to abide by the terms of an export license that permits more or fewer capabilities than those allowed by <CODE>NSS_SetExportPolicy</CODE>. In that case, you should first call <A HREF="sslfnc.html#1100560"><CODE>NSS_SetDomesticPolicy</CODE></A>, <A HREF="sslfnc.html#1100285"><CODE>NSS_SetExportPolicy</CODE></A>, or <A HREF="sslfnc.html#1105952"><CODE>NSS_SetFrancePolicy</CODE></A>, then call <A HREF="sslfnc.html#1104647"><CODE>SSL_SetPolicy</CODE></A> repeatedly to explicitly allow or disallow cipher suites until only those that you may legally export are permitted. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1122676">
 Important
</A></H5>

<A NAME="1122677">
If you call <CODE>NSS_SetExportPolicy</CODE> sometime after initialization to change 
cipher suite policy settings, you must also call <CODE>SSL_ClearSessionCache</CODE>. 
Otherwise, the old settings remain in the session cache and will be used instead 
of the new settings. 
</A>
</BLOCKQUOTE>

<H4><A NAME="Head3;"></A>
<A NAME="1105952">
 NSS_SetFrancePolicy
</A></H4>

<A NAME="1105968">
Configures the SSL cipher suites to conform with French import regulations related to software products with encryption features.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1105953">
 Syntax
</A></H5>

<PRE><A NAME="1105954">extern SECStatus NSS_SetFrancePolicy(void);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1106028">
 Returns
</A></H5>

<A NAME="1106029">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1106030">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1106033">
If unsuccessful, returns <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1105955">
 Description
</A></H5>

<A NAME="1119603">
<CODE>NSS_SetFrancePolicy</CODE> configures all the cipher suites listed under <A HREF="sslfnc.html#1104647"><CODE>SSL_SetPolicy</CODE></A> to conform with current U.S. export regulations and French import regulations (as Netscape understands them) related to software products with encryption features. Calling this function permits use of cipher suites listed below (but doesn't necessarily enable them; see <A HREF="sslfnc.html#1098841">SSL Export Policy Functions</A>). Policy for these suites is set to <CODE>SSL_ALLOWED</CODE>. For more details on policy settings, see <A HREF="sslfnc.html#1104647"><CODE>SSL_SetPolicy</CODE></A>.</A></P>
<A NAME="1119852">
For SSL 2.0:</A></P>
<ul><P><LI><A NAME="1119853">
<CODE>SSL_EN_RC4_128_EXPORT40_WITH_MD5</CODE></A></LI>
<P><LI><A NAME="1119854">
<CODE>SSL_EN_RC2_128_CBC_EXPORT40_WITH_MD5</CODE></A></LI>
</ul><A NAME="1119855">
For SSL 3.0:</A></P>
<ul><P><LI><A NAME="1119856">
<CODE>SSL_RSA_WITH_NULL_MD5</CODE></A></LI>
<P><LI><A NAME="1119859">
<CODE>SSL_RSA_EXPORT_WITH_RC4_40_MD5</CODE></A></LI>
<P><LI><A NAME="1119860">
<CODE>SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5</CODE></A></LI>
</ul><A NAME="1110037">
Under some circumstances, you may be required to abide by the terms of an export license that permits more or fewer capabilities than those allowed by <CODE>NSS_SetFrancePolicy</CODE>. In that case, you should first call <A HREF="sslfnc.html#1100560"><CODE>NSS_SetDomesticPolicy</CODE></A>, <A HREF="sslfnc.html#1100285"><CODE>NSS_SetExportPolicy</CODE></A>, or <A HREF="sslfnc.html#1105952"><CODE>NSS_SetFrancePolicy</CODE></A>, then call <A HREF="sslfnc.html#1104647"><CODE>SSL_SetPolicy</CODE></A> repeatedly to explicitly allow or disallow cipher suites until only those that you may legally export are permitted.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1122751">
 Important
</A></H5>

<A NAME="1122752">
If you call <CODE>NSS_SetFrancePolicy</CODE> sometime after initialization to change 
cipher suite policy settings, you must also call <CODE>SSL_ClearSessionCache</CODE>. 
Otherwise, the old settings remain in the session cache and will be used instead 
of the new settings. 
</A>
</BLOCKQUOTE>

<H4><A NAME="Head3;"></A>
<A NAME="1104647">
 SSL_SetPolicy
</A></H4>

<A NAME="1104648">
Sets policy for the use of individual cipher suites.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1104649">
 Syntax
</A></H5>

<PRE><A NAME="1104650">#include &lt;ssl.h&gt;<br>#include &lt;sslproto.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1104651">SECStatus SSL_SetPolicy(long which, int policy);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1104652">
 Parameters
</A></H5>

<A NAME="1104669">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1104655">
<CODE>which</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1104657">
A value from one of the following lists.</A></P><P><A NAME="1125144">
</A></P><P><A NAME="1125141">
Values for SSL2 (all are disallowed by default):</A></P><P><A NAME="1104658">
 <CODE>SSL_EN_RC4_128_WITH_MD5<br>SSL_EN_RC4_128_EXPORT40_WITH_MD5<br>SSL_EN_RC2_128_CBC_WITH_MD5<br>SSL_EN_RC2_128_CBC_EXPORT40_WITH_MD5<br>SSL_EN_DES_64_CBC_WITH_MD5<br>SSL_EN_DES_192_EDE3_CBC_WITH_MD5</CODE></A></P><P><A NAME="1104659">
&nbsp;</A></P><P><A NAME="1104660">
Values for SSL3 (all are disallowed by default):</A></P><P><A NAME="1104661">
<CODE>SSL_RSA_WITH_NULL_MD5</CODE><br><CODE>SSL_RSA_EXPORT_WITH_RC4_40_MD5<br>SSL_RSA_WITH_RC4_128_MD5<br>SSL_RSA_WITH_RC4_128_SHA<br>SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5<br>SSL_RSA_EXPORT_WITH_DES40_CBC_SHA<br>SSL_RSA_WITH_DES_CBC_SHA<br>SSL_RSA_WITH_3DES_EDE_CBC_SHA<br>SSL_FORTEZZA_DMS_WITH_NULL_SHA</CODE><br><CODE>SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA<br>SSL_FORTEZZA_DMS_WITH_RC4_128_SHA<br>SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA<br>SSL_RSA_FIPS_WITH_DES_CBC_SHA</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1104663">
<CODE>policy</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1104665">
One of the following values:</A></P><ul></P><LI><A NAME="1104666">
<CODE>SSL_ALLOWED</CODE>. Cipher is always allowed by U.S. government policy.   </A></P><LI><A NAME="1104667">
<CODE>SSL_RESTRICTED</CODE>. Cipher is allowed by U.S. government policy for servers with Global ID certificates. </A></P><LI><A NAME="1104668">
<CODE>SSL_NOT_ALLOWED</CODE>. Cipher is never allowed by U.S. government policy.</A></ul>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1104670">
 Returns
</A></H5>

<A NAME="1104671">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1104672">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1104675">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1104676">
 Description
</A></H5>

<A NAME="1104677">
Under some circumstances, you may be required to abide by the terms of an export license that permits more or fewer capabilities than those allowed by <A HREF="sslfnc.html#1100560"><CODE>NSS_SetDomesticPolicy</CODE></A>, <A HREF="sslfnc.html#1100285"><CODE>NSS_SetExportPolicy</CODE></A>, or <A HREF="sslfnc.html#1105952"><CODE>NSS_SetFrancePolicy</CODE></A>. In that case, first call <A HREF="sslfnc.html#1100560"><CODE>NSS_SetDomesticPolicy</CODE></A>, <A HREF="sslfnc.html#1100285"><CODE>NSS_SetExportPolicy</CODE></A>, or <A HREF="sslfnc.html#1105952"><CODE>NSS_SetFrancePolicy</CODE></A>, then call <CODE>SSL_SetPolicy</CODE> repeatedly to explicitly allow or disallow cipher suites until only those that you may legally export are permitted.</A></P>
<A NAME="1110096">
In a domestic US product, all the cipher suites are (presently) allowed. In an export client product, some cipher suites are always allowed (such as those with 40-bit keys), some are never allowed (such as triple-DES), and some are allowed (such as RC4_128) for use with approved servers, typically servers owned by banks with special Global ID certificates. (For details, see <A HREF="sslfnc.html#1100285"><CODE>NSS_SetExportPolicy</CODE></A> and <A HREF="sslfnc.html#1105952"><CODE>NSS_SetFrancePolicy</CODE></A>.) When an SSL connection is established, SSL uses only cipher suites that have previously been explicitly permitted by a call to one of the SSL export policy functions.</A></P>
<A NAME="1104678">
Note that the value <CODE>SSL_RESTRICTED</CODE> (passed in the <CODE>policy</CODE> parameter) is currently used only by SSL clients, which can use it to set policy for connections with servers that have Global ID certificates.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1123038">
 Important
</A></H5>

<A NAME="1123039">
If you call <CODE>SSL_SetPolicy</CODE> sometime after initialization to change cipher suite 
policy settings, you must also call <CODE>SSL_ClearSessionCache</CODE>. Otherwise, the 
old settings remain in the session cache and will be used instead of the new 
settings. 
</A>
</BLOCKQUOTE>
<H5><A NAME="Head4;"></A>
<A NAME="1106511">
 See Also
</A></H5>

<A NAME="1120368">
Permitting a cipher suite is not necessarily the same as enabling it. For details, see <A HREF="sslfnc.html#1098841">SSL Export Policy Functions</A>.</A></P>
<A NAME="1163847">
For descriptions of cipher suites supported by SSL, see <A HREF="../pkin/index.htm" TARGET="_top">Introduction to SSL</A>.</A></P>
<A NAME="1163849">
. </A></P>

<H2><A NAME="SSL Configuration Functions"></A>
<A NAME="1163855">
 SSL Configuration Functions
</A></H2><A NAME="1090054">
SSL configuration involves several NSPR functions in addition to the SSL functions listed here. For a complete list of configuration functions, see <A HREF="sslintro.html#1027742">Configuration</A>. </A></P>
<A NAME="1090814">
<A HREF="sslfnc.html#1090577">SSL Configuration</A><br><A HREF="sslfnc.html#1089578">Callback Configuration</A></A></P>

<H3><A NAME="Head2;"></A>
<A NAME="1090577">
 SSL Configuration
</A></H3>

<A NAME="1090637">
<A HREF="sslfnc.html#1085950"><CODE>SSL_ImportFD</CODE></A><br><A HREF="sslfnc.html#1086543"><CODE>SSL_Enable</CODE></A><br><A HREF="sslfnc.html#1087163"><CODE>SSL_ConfigSecureServer</CODE></A><br><A HREF="sslfnc.html#1087792"><CODE>SSL_SetURL</CODE></A><br><A HREF="sslfnc.html#1088040"><CODE>SSL_SetPKCS11PinArg</CODE></A></A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1085950">
 SSL_ImportFD
</A></H4>

<A NAME="1085951">
Imports an existing NSPR file descriptor into SSL and returns a new SSL socket.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1085952">
 Syntax
</A></H5>

<PRE><A NAME="1085953">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;</A></PRE><PRE><A NAME="1085954">PRFileDesc *SSL_ImportFD(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *model,<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1085955">
 Parameters
</A></H5>

<A NAME="1085965">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1085958">
<CODE>model</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1085960">
A pointer to the model file descriptor.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1085962">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1085964">
A pointer to the file descriptor for the new SSL socket.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1085966">
 Returns
</A></H5>

<A NAME="1085967">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1085968">
If successful, a pointer to a new socket file descriptor.</A></LI>
<LI><A NAME="1085969">
If unsuccessful, <CODE>NULL</CODE>.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1085970">
 Description
</A></H5>

<A NAME="1085971">
Any SSL function that takes a pointer to a file descriptor (socket) as a parameter will have no effect (even though the SSL function may return <CODE>SECSuccess</CODE>) if the socket is not an SSL socket. Sockets do not automatically become secure SSL sockets when they are created by the NSPR functions. You must pass an NSPR socket's file descriptor to <CODE>SSL_ImportFD</CODE> to make it an SSL socket before you call any other SSL function that takes the socket's file descriptor as a parameter</A></P>
<A NAME="1091276">
<CODE>SSL_ImportFD</CODE> imports an existing NSPR file descriptor into SSL and returns a new SSL socket file descriptor. If the <CODE>model</CODE> parameter is not <CODE>NULL</CODE>, the configuration of the new file descriptor is copied from the model. If the <CODE>model</CODE> parameter is <CODE>NULL</CODE>, then the default SSL configuration is used.</A></P>
<A NAME="1120376">
The new file descriptor returned by <CODE>SSL_ImportFD</CODE> is not necessarily equal to the original NSPR file descriptor. If, after calling <CODE>SSL_ImportFD</CODE>, the file descriptors are not equal, you should perform all operations on the new <CODE>PRFileDesc</CODE> structure, never the old one. Even when it's time to close the file descriptor, always close the new <CODE>PRFileDesc</CODE> structure, never the old one.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1086543">
 SSL_Enable
</A></H4>

<A NAME="1086544">
Sets a single configuration parameter of a specified socket. Call once for each parameter you want to change.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1086545">
 Syntax
</A></H5>

<PRE><A NAME="1086546">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;prtypes.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1086547">SECStatus SSL_Enable(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;int which, <br>&nbsp;&nbsp;&nbsp;PRBool on);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1086548">
 Parameters
</A></H5>

<A NAME="1086570">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1086551">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1086553">
Pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1086555">
<CODE>which</CODE></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1086557">
One of the following values (default values are determined by the use of <A HREF="sslfnc.html#1068466"><CODE>SSL_EnableDefault</CODE></A>):</A></P>
<ul></P><LI><A NAME="1086558">
<CODE>SSL_SECURITY</CODE> enables use of security protocol. <EM>WARNING</EM>: If you turn this option off, the session will not be an SSL session and will not have certificate-based authentication, tamper detection, or encryption.</A></P><LI><A NAME="1134670">
<CODE>SSL_REQUEST_CERTIFICATE</CODE> is a server option that requests a client to authenticate itself. </A></P><LI><A NAME="1134671">
<CODE>SSL_REQUIRE_CERTIFICATE</CODE> is a server option that requires a client to authenticate itself (only if <CODE>SSL_REQUEST_CERTIFICATE</CODE> is also on). If client does not provide certificate, the connection terminates. </A></P><LI><A NAME="1134672">
<CODE>SSL_HANDSHAKE_AS_CLIENT</CODE> forces handshake as a client, with or without authentication. </A></P><LI><A NAME="1134673">
<CODE>SSL_HANDSHAKE_AS_SERVER</CODE> forces handshake as a server, with or without authentication. </A></P><LI><A NAME="1134674">
<CODE>SSL_ENABLE_SSL3</CODE> enables the application to communicate with SSL v3. If you turn this option off, an attempt to establish a connection with a peer that understands only SSL v3 will fail.</A></P><LI><A NAME="1134675">
<CODE>SSL_ENABLE_SSL2</CODE> enables the application to communicate with SSL v2. If you turn this option off, an attempt to establish a connection with a peer that understands only SSL v2 will fail.</A></P><LI><A NAME="1086565">
<CODE>SSL_NO_CACHE</CODE> disallows use of the session cache for this socket. If you turn this option on, this socket will be unable to resume a session begun by another socket. When this socket's session is finished, no other socket will be able to resume the session begun by this socket. </A></ul>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1086567">
<CODE>on</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1086569">
 <CODE>PR_TRUE</CODE> turns option on; <CODE>PR_FALSE</CODE> turns option off.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1086571">
 Returns
</A></H5>

<A NAME="1086572">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1086573">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1086576">
If unsuccessful, returns <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1086577">
 Description
</A></H5>

<A NAME="1086578">
Keep the following in mind when deciding on the configuration parameters you want to use with a particular socket: </A></P>
<ul><P><LI><A NAME="1086579">
Turning on <CODE>SSL_REQUIRE_CERTIFICATE</CODE> will have no effect unless <CODE>SSL_REQUEST_CERTIFICATE</CODE> is also turned on. If you enable <CODE>SSL_REQUEST_CERTIFICATE</CODE>, then you should explicitly enable or disable <CODE>SSL_REQUIRE_CERTIFICATE</CODE> rather than allowing it to default. Enabling the <CODE>SSL_REQUIRE_CERTIFICATE</CODE> option is not recommended. If the client has no certificate and this option is enabled, the client's connection terminates with an error. The user is likely to think something is wrong with either the client or the server, and is unlikely to realize that the problem is the lack of a certificate. It is better to allow the SSL handshake to complete and then return an error message to the client that informs the user of the need for a certificate.</A></LI>
<P><LI><A NAME="1136094">
If both <CODE>SSL_HANDSHAKE_AS_CLIENT</CODE> and <CODE>SSL_HANDSHAKE_AS_SERVER</CODE> are turned off, then whether the socket is that of a client or that of a server depends on how you open the socket. If you use <A href="../../../../../../docs/refList/refNSPR/priofnc.html#439145" ><CODE>PR_Accept</A></CODE>, the socket is that of a server. If you use <A href="../../../../../../docs/refList/refNSPR/priofnc.html#436330" ><CODE>PR_Connect</A></CODE>, the socket is that of a client. See also <A HREF="sslfnc.html#1087163"><CODE>SSL_ConfigSecureServer</CODE></A>.</A></LI>
<P><LI><A NAME="1086580">
<CODE>SSL_HANDSHAKE_AS_CLIENT</CODE> and <CODE>SSL_HANDSHAKE_AS_SERVER</CODE> cannot both be set to on simultaneously. If you attempt to turn one option on when the other is already on, <CODE>SSL_EnableDefault</CODE> fails, returning with the error code set to <CODE>SEC_ERROR_INVALID_ARGS</CODE>.</A></LI>
</ul>
<H4><A NAME="Head3;"></A>
<A NAME="1087163">
 SSL_ConfigSecureServer
</A></H4>

<A NAME="1087164">
Configures a listen socket with the information needed to handshake as an SSL server. <CODE>SSL_ConfigSecureServer</CODE> requires the certificate for the server and the server's private key. The arguments are copied.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1087165">
 Syntax
</A></H5>

<PRE><A NAME="1087166">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;seccomon.h&gt;<br>#include &lt;certt.h&gt;<br>#include &lt;keyt.h&gt;</A></PRE><PRE><A NAME="1087167">SECStatus SSL_ConfigSecureServer(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;CERTCertificate *cert,<br>&nbsp;&nbsp;&nbsp;SECKEYPrivateKey *key,<br>&nbsp;&nbsp;&nbsp;SSLKEAType keaType);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1087168">
 Parameters
</A></H5>

<A NAME="1087182">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1087171">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1087173">
A pointer to the file descriptor for the SSL listen socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1087175">
<CODE>cert</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1087177">
A pointer to the server's certificate structure.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1087179">
<CODE>key</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1087181">
A pointer to the server's private key structure.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1107228">
<CODE>keaType</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1107230">
Key exchange type for use with specified certificate and key. These values are currently valid: </A></P><ul></P><LI><A NAME="1122023">
<CODE>kt_rsa</CODE></A></P><LI><A NAME="1121871">
<CODE>kt_dh</CODE></A></P><LI><A NAME="1107277">
<CODE>kt_fortezza</CODE></A></ul>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1087183">
 Returns
</A></H5>

<A NAME="1087184">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1087185">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1087188">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1087189">
 Description
</A></H5>

<A NAME="1127383">
Your program always handshakes as a client unless you call <CODE>SSL_ConfigSecureServer</CODE>, or turn on the <CODE>SSL_HANDSHAKE_AS_SERVER</CODE> option with <A HREF="sslfnc.html#1086543"><CODE>SSL_Enable</CODE></A> or <A HREF="sslfnc.html#1068466"><CODE>SSL_EnableDefault</CODE></A>. Once you have used this function to configure the listen socket, child sockets created by calls to <A href="../../../../../../docs/refList/refNSPR/priofnc.html#439145" ><CODE>PR_Accept</A></CODE> inherit the configuration. </A></P>
<A NAME="1127390">
Servers can be configured with more than one certificate for a given port, and different certificates can support different key-exchange algorithms. To find out what key-exchange algorithm a particular certificate supports, pass the certificate structure to <A HREF="sslcrt.html#1056950"><CODE>NSS_FindCertKEAType</CODE></A>. You can then pass the <CODE>SSLKEAType</CODE> value returned by <CODE>NSS_FindCertKEAType</CODE> in the <CODE>keaType</CODE> parameter of <CODE>SSL_ConfigSecureServer</CODE>. The server uses the specified key-exchange algorithm with the specified certificate and key. </A></P>
<A NAME="1148755">
When the <CODE>keaType</CODE> is <CODE>kt_rsa</CODE>, this function generates a step-down key that is supplied as part of the handshake if needed. (A step-down key is needed when the server's public key is stronger than is allowed for export ciphers.) In this case, if the server is expected to continue running for a long time, you should call this function periodically (once a day, for example) to generate a new step-down key.</A></P>
<A NAME="1127391">
SSL makes and keeps internal copies (or increments the reference counts, as appropriate) of certificate and key structures. The application should destroy its copies when it has no further use for them by calling <A HREF="sslcrt.html#1050532"><CODE>CERT_DestroyCertificate</CODE></A> and <A HREF="sslkey.html#1051017"><CODE>SECKEY_DestroyPrivateKey</CODE></A>. </A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1087792">
 SSL_SetURL
</A></H4>

<A NAME="1087793">
Sets the domain name of the intended server in the client's SSL socket. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1087794">
 Syntax
</A></H5>

<PRE><A NAME="1087795">#include &lt;ssl.h&gt; </A></PRE><PRE><A NAME="1087796">int SSL_SetURL(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;char *url);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1087797">
 Parameters 
</A></H5>

<A NAME="1087807">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1087800">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1087802">
A pointer to a file descriptor.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1087804">
<CODE>url</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1087806">
A pointer to a string specifying the desired server's domain name.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1087808">
 Returns
</A></H5>

<A NAME="1087809">
The function returns one of the following values:</A></P>
<ul><P><LI><A NAME="1087810">
If successful, zero.</A></LI>
<LI><A NAME="1087813">
If unsuccessful, <CODE>-1</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1130686">
 Description
</A></H5>

<A NAME="1130687">
The client application's certificate authentication callback function needs to compare the domain name in the server's certificate against the domain name of the server the client was attempting to contact. This step is vital because it is the client's <I>only</I> protection against a man-in-the-middle attack. </A></P>
<A NAME="1087816">
The client application uses <CODE>SSL_SetURL</CODE> to set the domain name of the desired server before performing the first SSL handshake. The client application's certificate authentication callback function gets this string by calling <A HREF="sslfnc.html#1081175"><CODE>SSL_RevealURL</CODE></A>.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1088040">
 SSL_SetPKCS11PinArg
</A></H4>

<A NAME="1088041">
Sets the argument passed to the password callback function specified by a call to <A HREF="pkfnc.html#1023128"><CODE>PK11_SetPasswordFunc</CODE></A>.<B> </B></A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1088045">
 Syntax
</A></H5>

<PRE><A NAME="1088046">#include &lt;ssl.h&gt;</A></PRE><PRE><A NAME="1088047">int SSL_SetPKCS11PinArg(PRFileDesc *fd, void *a); </A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1088048">
 Parameters
</A></H5>

<A NAME="1088058">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088051">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088053">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088055">
<CODE>a</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088057">
A pointer supplied by the application that can be used to pass state information. This value is passed as the third argument of the application's password function. The meaning is determined solely by the application.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1088059">
 Returns
</A></H5>

<A NAME="1088060">
The function returns one of the following values:</A></P>
<ul><P><LI><A NAME="1088061">
If successful, zero.</A></LI>
<LI><A NAME="1088064">
If unsuccessful, <CODE>-1</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1088065">
 Description
</A></H5>

<A NAME="1088066">
During the course of an SSL operation, it may be necessary for the user to log in to a PKCS #11 token (either a smart card or soft token) to access protected information, such as a private key. Such information is protected with a password that can be retrieved by calling an application-supplied callback function. The callback function is specified in a call to <A HREF="pkfnc.html#1023128"><CODE>PK11_SetPasswordFunc</CODE></A> that takes place during NSS initialization. </A></P>
<A NAME="1123150">
Several functions in the NSS libraries use the password callback function to obtain the password before performing operations that involve the protected information. When NSS libraries call the password callback function, the value they pass in as the third parameter is the value of the <CODE>a</CODE> argument to <CODE>PK11_SetPKCS11PinArg</CODE>. The third parameter to the password callback function is application-defined and can be used for any purpose. For example, Communicator uses the parameter to pass information about which window is associated with the modal dialog box requesting the password from the user. </A></P>
<A NAME="1148228">
You can obtain the PIN argument by calling <A HREF="sslfnc.html#1123385"><CODE>SSL_RevealPinArg</CODE></A>.</A></P>

<H3><A NAME="Head2;"></A>
<A NAME="1089578">
 Callback Configuration
</A></H3>

<A NAME="1089579">
At the beginning of an SSL application, it is often necessary to set up callback functions for the SSL API to use when it needs to call the application. These functions are used to request authentication information from the application or to inform the application when a handshake is completed.</A></P>
<A NAME="1089583">
<A HREF="sslfnc.html#1088805"><CODE>SSL_AuthCertificateHook</CODE></A><br><A HREF="sslfnc.html#1088888"><CODE>SSL_AuthCertificate</CODE></A><br><A HREF="sslfnc.html#1088928"><CODE>SSL_BadCertHook</CODE></A><br><A HREF="sslfnc.html#1126622"><CODE>SSL_GetClientAuthDataHook</CODE></A><br><A HREF="sslfnc.html#1106762"><CODE>NSS_GetClientAuthData</CODE></A><br><A HREF="sslfnc.html#1112702"><CODE>SSL_HandshakeCallback</CODE></A></A></P>
<A NAME="1123332">
Setting up the callback functions described in this section may be optional for some applications. However, all applications must use <A HREF="pkfnc.html#1023128"><CODE>PK11_SetPasswordFunc</CODE></A> to set up the password callback function during NSS initialization.</A></P>
<A NAME="1126377">
For examples of the callback functions listed here, see <A HREF="gtstd.html#1005439">Chapter&nbsp;2, "Getting Started With SSL."</A></A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1088805">
 SSL_AuthCertificateHook
</A></H4>

<A NAME="1088806">
Specifies a certificate authentication callback function called to authenticate an incoming certificate.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1088807">
 Syntax
</A></H5>

<PRE><A NAME="1088808">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;prtypes.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1088809">SECStatus SSL_AuthCertificateHook(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;SSLAuthCertificate f,<br>&nbsp;&nbsp;&nbsp;void *arg);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1088810">
 Parameters
</A></H5>

<A NAME="1088827">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088813">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088815">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088817">
<CODE>f</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088819">
A pointer to the callback function. If <CODE>NULL</CODE>, the default function, <A HREF="sslfnc.html#1088888"><CODE>SSL_AuthCertificate</CODE></A>, will be used.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088824">
<CODE>arg</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088826">
A pointer supplied by the application that can be used to pass state information. Can be <CODE>NULL</CODE>.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1088828">
 Returns
</A></H5>

<A NAME="1088829">
The function returns one of the following values:</A></P>
<ul><P><LI><A NAME="1088830">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1088833">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1088834">
 Description
</A></H5>

<A NAME="1088835">
The callback function set up by <CODE>SSL_AuthCertificateHook</CODE> is called to authenticate an incoming certificate. If the <CODE>checksig</CODE> parameter is set to <CODE>PR_TRUE</CODE>, the callback function also verifies the digital signature. </A></P>
<BLOCKQUOTE><B>NOTE: </B><A NAME="1132358">
If you do not call<CODE> SSL_AuthCertificateHook</CODE> to supply a certificate 
authentication callback function, SSL uses the default callback function, 
<A HREF="sslfnc.html#1088888"><CODE>SSL_AuthCertificate</CODE></A>. 
</A>
</BLOCKQUOTE>
<A NAME="1088836">
The callback function has the following prototype:</A></P>
<PRE><A NAME="1088837">typedef SECStatus (*SSLAuthCertificate) (<br>&nbsp;&nbsp;&nbsp;void *arg,<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;PRBool checksig,<br>&nbsp;&nbsp;&nbsp;PRBool isServer);</A></PRE><A NAME="1088855">
This callback function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088840">
<CODE>arg</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088842">
A pointer supplied by the application (in the call to <CODE>SSL_AuthCertificateHook</CODE>) that can be used to pass state information. Can be <CODE>NULL</CODE>. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088844">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088846">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088848">
<CODE>checksig</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088850">
<CODE>PR_TRUE </CODE>means signatures are to be checked and the certificate chain is to be validated. <CODE>PR_FALSE</CODE> means they are not to be checked. (The value is normally <CODE>PR_TRUE</CODE>.)</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088852">
<CODE>isServer</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088854">
<CODE>PR_TRUE</CODE> means the callback function should evaluate the certificate as a server does, treating the remote end is a client. <CODE>PR_FALSE</CODE> means the callback function should evaluate the certificate as a client does, treating the remote end as a server.</A></P>

</TABLE>
</A></P>
<A NAME="1088856">
The callback function returns one of these <CODE>values</CODE>:</A></P>
<ul><P><LI><A NAME="1088857">
If authentication is successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1088858">
If authentication is not successful, <CODE>SECFailure</CODE>. If the callback returns <CODE>SECFailure</CODE>, the callback should indicate the reason for the failure (if possible) by calling <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> with the appropriate error code. 
</A></LI></ul><A NAME="1088859">
The callback function obtains the certificate to be authenticated by calling <A HREF="sslfnc.html#1096168"><CODE>SSL_PeerCertificate</CODE></A>.</A></P>
<A NAME="1088863">
If <CODE>isServer</CODE> is false, the callback should also check that the domain name in the remote server's certificate matches the desired domain name specified in a previous call to <A HREF="sslfnc.html#1087792"><CODE>SSL_SetURL</CODE></A>. To obtain that domain name, the callback calls <A HREF="sslfnc.html#1081175"><CODE>SSL_RevealURL</CODE></A>. </A></P>
<A NAME="1088870">
The callback may need to call one or more PK11 functions to obtain the services of a PKCS #11 module. Some of the PK11 functions require a PIN argument (see <A HREF="sslfnc.html#1088040"><CODE>SSL_SetPKCS11PinArg</CODE></A> for details). To obtain the value that was set with <A HREF="sslfnc.html#1088040"><CODE>SSL_SetPKCS11PinArg</CODE></A>, the callback calls <A HREF="sslfnc.html#1123385"><CODE>SSL_RevealPinArg</CODE></A>. </A></P>
<A NAME="1088878">
If the callback returns <CODE>SECFailure</CODE>, the SSL connection is terminated immediately unless the application has supplied a bad-certificate callback function by having previously called <A HREF="sslfnc.html#1088928"><CODE>SSL_BadCertHook</CODE></A>. A bad-certificate callback function gives the application the opportunity to choose to accept the certificate as authentic and authorized even though it failed the check performed by the certificate authentication callback function. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1126522">
 See Also
</A></H5>

<A NAME="1126559">
For examples of certificate authentication callback functions, see the sample code referenced from <A HREF="gtstd.html#1005439">Chapter&nbsp;2, "Getting Started With SSL."</A></A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1088888">
 SSL_AuthCertificate
</A></H4>

<A NAME="1088889">
Default callback function used to authenticate certificates received from the remote end of an SSL connection if the application has not previously called <A HREF="sslfnc.html#1088805"><CODE>SSL_AuthCertificateHook</CODE></A> to specify its own certificate authentication callback function.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1088893">
 Syntax
</A></H5>

<PRE><A NAME="1088894">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;prtypes.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1088895">SECStatus SSL_AuthCertificate(<br>&nbsp;&nbsp;&nbsp;void *arg,<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;PRBool checksig,<br>&nbsp;&nbsp;&nbsp;PRBool isServer);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1088896">
 Parameters
</A></H5>

<A NAME="1088914">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088899">
<CODE>arg</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088901">
A pointer to the handle of the certificate database to be used in validating the certificate's signature. (This use of the <CODE>arg</CODE> parameter is required for <CODE>SSL_AuthCertificate</CODE>, but not for all implementations of a certificate authentication callback function.)</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088903">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088905">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088907">
<CODE>checksig</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1126103">
<CODE>PR_TRUE </CODE>means signatures are to be checked and the certificate chain is to be validated. <CODE>PR_FALSE</CODE> means they are not to be checked. (The value is normally <CODE>PR_TRUE</CODE>.)</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088911">
<CODE>isServer</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088913">
<CODE>PR_TRUE</CODE> means the callback function should evaluate the certificate as a server does, treating the remote end is a client. <CODE>PR_FALSE</CODE> means the callback function should evaluate the certificate as a client does, treating the remote end as a server.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1088915">
 Returns
</A></H5>

<A NAME="1088916">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1088917">
If authentication is successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1088918">
If authentication is not successful, <CODE>SECFailure</CODE>. 
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1088919">
 Description
</A></H5>

<A NAME="1088920">
SSL calls <CODE>SSL_AuthCertificate</CODE> by default (if no other callback function is provided) to authenticate an incoming certificate. If the <CODE>checksig</CODE> parameter is set to <CODE>PR_TRUE</CODE> (which is normally the case), the function also verifies the digital signature and the certificate chain. </A></P>
<A NAME="1110615">
If the socket is a client socket, <CODE>SSL_AuthCertificate</CODE> tests the domain name in the SSL socket against the domain name in the server certificate's subject DN:</A></P>
<ul><P><LI><A NAME="1110647">
If the domain name in the SSL socket doesn't match the domain name in the server certificate's subject DN, the function fails.</A></LI>
<P><LI><A NAME="1110672">
If the SSL socket has not had a domain name set (that is, if <A HREF="sslfnc.html#1087792"><CODE>SSL_SetURL</CODE></A> has not been called) or its domain name is set to an empty string, the function fails.</A></LI>
</ul><A NAME="1088922">
The implementation of the certificate authentication callback function shown in the <CODE>client.c</CODE> sample in the <A HREF="../../../Samples/" TARGET="_top">Samples</A> directory is functionally identical to the implementation of <CODE>SSL_AuthCertificate</CODE>. </A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1088928">
 SSL_BadCertHook
</A></H4>

<A NAME="1088932">
Sets up a callback function to deal with a situation where the <A HREF="sslfnc.html#1088888"><CODE>SSL_AuthCertificate</CODE></A> callback function has failed. This callback function allows the application to override the decision made by the certificate authorization callback and authorize the certificate for use in the SSL connection. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1088933">
 Syntax
</A></H5>

<PRE><A NAME="1088934">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1088935">SECStatus SSL_BadCertHook(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;SSLBadCertHandler f,<br>&nbsp;&nbsp;&nbsp;void *arg);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1088936">
 Parameters
</A></H5>

<A NAME="1088950">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088939">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088941">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088943">
<CODE>f</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088945">
A pointer to the application's callback function. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088947">
<CODE>arg</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088949">
A pointer supplied by the application that can be used to pass state information. Can be <CODE>NULL</CODE>.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1088952">
 Returns
</A></H5>

<A NAME="1088953">
The function returns one of these value<VAR>s</VAR>:</A></P>
<ul><P><LI><A NAME="1088954">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1088957">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1088958">
 Description
</A></H5>

<A NAME="1088959">
The bad-certificate callback function gives the program an opportunity to do something (for example, log the attempt or authorize the certificate) when certificate authentication is not successful. If such a callback function is not provided by the application, the SSL connection simply fails when certificate authentication is not successful.</A></P>
<A NAME="1088960">
The callback function set up by <CODE>SSL_BadCertHook</CODE> has the following prototype:</A></P>
<PRE><A NAME="1088961">typedef SECStatus (*SSLBadCertHandler)(<br>&nbsp;&nbsp;&nbsp;void *arg,<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd);</A></PRE><A NAME="1088974">
This callback function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088964">
<CODE>arg</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088966">
The <CODE>arg</CODE> parameter passed to <A HREF="sslfnc.html#1088928"><CODE>SSL_BadCertHook</CODE></A>.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1088971">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1088973">
A pointer to the file descriptor for the SSL socket.</A></P>

</TABLE>
</A></P>
<A NAME="1088975">
The callback function returns one of these values: </A></P>
<ul><P><LI><A NAME="1088976">
<CODE>SECSuccess</CODE>: The callback has chosen to authorize the certificate for use in this SSL connection, despite the fact that it failed the examination by the certificate authentication callback.</A></LI>
<LI><A NAME="1088977">
<CODE>SECFailure</CODE>: The certificate is not authorized for this SSL connection. The SSL connection will be terminated immediately.
</A></LI></ul><A NAME="1088978">
To obtain the certificate that was rejected by the certificate authentication callback, the callback function calls <A HREF="sslfnc.html#1096168"><CODE>SSL_PeerCertificate</CODE></A>. Since it is called immediately after the certificate authentication callback returns, the bad-certificate callback function can obtain the error code set by the certificate authentication callback by calling <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> immediately, as the first operation it performs. </A></P>
<A NAME="1126612">
The callback may need to call one or more PK11 functions to obtain the services of a PKCS #11 module. Some of the PK11 functions require a PIN argument (see <A HREF="sslfnc.html#1088040"><CODE>SSL_SetPKCS11PinArg</CODE></A> for details). To obtain the value previously passed, the callback calls <A HREF="sslfnc.html#1123385"><CODE>SSL_RevealPinArg</CODE></A></A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1126637">
 See Also
</A></H5>

<A NAME="1126643">
For examples of bad certificate callback functions, see the <CODE>client.c</CODE> and <CODE>server.c</CODE> samples in the <A HREF="../../../Samples/" TARGET="_top">Samples</A> directory.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1126622">
 SSL_GetClientAuthDataHook
</A></H4>

<A NAME="1088993">
Defines a callback function for SSL to use in a client application when a server asks for client authentication information. This callback function is required if your client application is going to support client authentication. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1088994">
 Syntax
</A></H5>

<PRE><A NAME="1088995">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;certt.h&gt;<br>#include &lt;keyt.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1088996">SECStatus SSL_GetClientAuthDataHook(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;SSLGetClientAuthData f,<br>&nbsp;&nbsp;&nbsp;void *a);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1088997">
 Parameters
</A></H5>

<A NAME="1089011">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089000">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089002">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089004">
<CODE>f</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089006">
A pointer to the application's callback function that delivers the key and certificate. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089008">
<CODE>arg</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089010">
A pointer supplied by the application that can be used to pass state information. Can be <CODE>NULL</CODE>.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1089012">
 Returns
</A></H5>

<A NAME="1089013">
The function returns one of these values: <B></B></A></P>
<ul><P><LI><A NAME="1089014">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1089017">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1089018">
 Description
</A></H5>

<A NAME="1110978">
The callback function set with <CODE>SSL_GetClientAuthDataHook</CODE> is used to get information from a client application when authentication is requested by the server. The callback function retrieves the client's private key and certificate. </A></P>
<A NAME="1110984">
SSL provides an implementation of this callback function; see <A HREF="sslfnc.html#1106762"><CODE>NSS_GetClientAuthData</CODE></A> for details. Unlike <A HREF="sslfnc.html#1088888"><CODE>SSL_AuthCertificate</CODE></A>, <A HREF="sslfnc.html#1106762"><CODE>NSS_GetClientAuthData</CODE></A> is not a default callback function. You must set it explicitly with <CODE>SSL_GetClientAuthDataHook</CODE> if you want to use it. </A></P>
<A NAME="1111005">
The callback function has the following prototype: </A></P>
<PRE><A NAME="1110979">typedef SECStatus (*SSLGetClientAuthData)(<br>&nbsp;&nbsp;&nbsp;void *arg,<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;CertDistNames *caNames, <br>&nbsp;&nbsp;&nbsp;CERTCertificate **pRetCert,<br>&nbsp;&nbsp;&nbsp;SECKEYPrivateKey **pRetKey);</A></PRE><A NAME="1089042">
This callback function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089023">
<CODE>arg</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089025">
The <CODE>arg</CODE> parameter passed to <CODE>SSL_GetClientAuthDataHook</CODE>. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089027">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089029">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089031">
<CODE>caNames</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089033">
A pointer to distinguished names of CAs that the server accepts.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089035">
<CODE>pRetCert</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089037">
A pointer to a pointer to a certificate structure, for returning the certificate.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089039">
<CODE>pRetKey</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089041">
A pointer to a pointer to a key structure, for returning the private key.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1089043">
 
</A></H5>

<A NAME="1089044">
The callback function returns one of these values:</A></P>
<ul><P><LI><A NAME="1089045">
If data returned is valid, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1089046">
If the function cannot obtain a certificate, <CODE>SECFailure</CODE>.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1126687">
 See Also
</A></H5>

<A NAME="1126695">
For an example of a client authentication data callback function, see the <CODE>client.c</CODE> sample in the <A HREF="../../../Samples/" TARGET="_top">Samples</A> directory.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1106762">
 NSS_GetClientAuthData
</A></H4>

<A NAME="1111069">
Callback function that a client application can use to get the client's private key and certificate when authentication is requested by a remote server. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1106807">
 Syntax
</A></H5>

<PRE><A NAME="1111065">#include &lt;nss.h&gt;</A></PRE><PRE><A NAME="1112354">SECStatus NSS_GetClientAuthData(<br>&nbsp;&nbsp;&nbsp;void * arg,<br>&nbsp;&nbsp;&nbsp;PRFileDesc *socket,<br>&nbsp;&nbsp;&nbsp;struct CERTDistNamesStr *caNames,<br>&nbsp;&nbsp;&nbsp;struct CERTCertificateStr **pRetCert,<br>&nbsp;&nbsp;&nbsp;struct SECKEYPrivateKeyStr **pRetKey);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1106813">
 Parameters
</A></H5>

<A NAME="1113996">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1113993">
<CODE>arg</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1114791">
The <CODE>arg</CODE> parameter passed to <CODE>SSL_GetClientAuthDataHook</CODE>, which should be a pointer to a <CODE>NULL</CODE>-terminated string containing the nickname of the certificate and key pair to use. If <CODE>arg</CODE> is <CODE>NULL</CODE>, <CODE>NSS_GetClientAuthData</CODE> searches the certificate and key databases for a suitable match and uses the certificate and key pair it finds, if any.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1115433">
<CODE>socket</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1115435">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1115437">
<CODE>caNames</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1115439">
A pointer to distinguished names of CAs that the server accepts.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1115441">
<CODE>pRetCert</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1115443">
A pointer to a pointer to a certificate structure, for returning the certificate.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1115445">
<CODE>pRetKey</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1115447">
A pointer to a pointer to a key structure, for returning the private key.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1114453">
 Returns
</A></H5>

<A NAME="1114454">
The function returns one of these values: </A></P>
<ul><P><LI><A NAME="1114455">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1114458">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1114347">
 Description
</A></H5>

<A NAME="1113322">
Unlike <A HREF="sslfnc.html#1088888"><CODE>SSL_AuthCertificate</CODE></A>, <CODE>NSS_GetClientAuthData</CODE> is not a default callback function. You must set it explicitly with <A HREF="sslfnc.html#1126622"><CODE>SSL_GetClientAuthDataHook</CODE></A> for each SSL client socket.</A></P>
<A NAME="1114636">
Once <CODE>NSS_GetClientAuthData</CODE> has been set for a client socket, SSL invokes it whenever SSL needs to know what certificate and private key (if any) to use to respond to a request for client authentication.</A></P>
<A NAME="1130593">
The implementation of the certificate authentication data callback function shown in the <CODE>client.c</CODE> sample in the <A HREF="../../../Samples/" TARGET="_top">Samples</A> directory is functionally identical to the implementation of <CODE>NSS_GetClientAuthData</CODE>. This implementation is provided as a convenience; applications can supply their own implementations.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1112702">
 SSL_HandshakeCallback
</A></H4>

<A NAME="1089049">
Sets up a callback function used by SSL to inform either a client application or a server application when the handshake is completed.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1089050">
 Syntax
</A></H5>

<PRE><A NAME="1089051">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1089052">SECStatus SSL_HandshakeCallback(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;SSLHandshakeCallback cb,<br>&nbsp;&nbsp;&nbsp;void *client_data);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1089053">
 Parameters
</A></H5>

<A NAME="1089067">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089056">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089058">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089060">
<CODE>cb</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089062">
A pointer to the application's callback function. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089064">
<CODE>client_data</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089066">
A pointer to the value of the <CODE>client_data</CODE> argument that was passed to <CODE>SSL_HandshakeCallback</CODE>.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1089068">
 Returns
</A></H5>

<A NAME="1089069">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1089070">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1089073">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1089074">
 Description
</A></H5>

<A NAME="1089075">
The callback function set by <CODE>SSL_HandshakeCallback</CODE> has the following prototype:</A></P>
<PRE><A NAME="1127151">typedef void (*SSLHandshakeCallback)(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;void *client_data);</A></PRE><A NAME="1127164">
This callback function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1127154">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1127156">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1127158">
<CODE>client_data</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1127160">
A pointer supplied by the application that can be used to pass state information. Can be <CODE>NULL</CODE>.</A></P>

</TABLE>
 </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1127310">
 See Also
</A></H5>

<A NAME="1127318">
For examples of handshake callback functions, see the samples in the <A HREF="../../../Samples/" TARGET="_top">Samples</A> directory.</A></P>

<H2><A NAME="SSL Communication Functions"></A>
<A NAME="1127321">
 SSL Communication Functions
</A></H2><A NAME="1090925">
Most communication functions are described in the <A href="../../../../../../docs/refList/refNSPR/contents.html>NSPR Reference</A>. For a complete list of communication functions used by SSL-enabled applications, see <A HREF="sslintro.html#1027816">Communication</A>. </A></P>
<A NAME="1092556">
<A HREF="sslfnc.html#1089420"><CODE>SSL_InvalidateSession</CODE></A><br><A HREF="sslfnc.html#1092785"><CODE>SSL_DataPending</CODE></A><br><A HREF="sslfnc.html#1092805"><CODE>SSL_SecurityStatus</CODE></A><br><A HREF="sslfnc.html#1092869"><CODE>SSL_GetSessionID</CODE></A><br><A HREF="sslfnc.html#1124562"><CODE>SSL_SetSockPeerID</CODE></A></A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1089420">
 SSL_InvalidateSession
</A></H4>

<A NAME="1089421">
Removes the current session on a particular SSL socket from the session cache.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1089422">
 Syntax
</A></H5>

<PRE><A NAME="1089423">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1089424">int SSL_InvalidateSession(PRFileDesc *fd);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1089425">
 Parameter
</A></H5>

<A NAME="1089431">
This function has the following parameter:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1089428">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1089430">
A pointer to the file descriptor for the SSL socket.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1089432">
 Returns
</A></H5>

<A NAME="1089433">
The function returns one of these values: </A></P>
<ul><P><LI><A NAME="1089434">
If successful, zero.</A></LI>
<LI><A NAME="1089437">
If unsuccessful, -1. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1089438">
 Description
</A></H5>

<A NAME="1089417">
After you call <CODE>SSL_InvalidateSession</CODE>, the existing connection using the session can continue, but it cannot be interrupted and then resume again without redoing the handshake. </A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1092785">
 SSL_DataPending
</A></H4>

<A NAME="1092786">
Returns the number of bytes waiting in internal SSL buffers to be read by the local application from the SSL socket.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1092787">
 Syntax
</A></H5>

<PRE><A NAME="1092788">#include &lt;ssl.h&gt;</A></PRE><PRE><A NAME="1092789">int SSL_DataPending(PRFileDesc *fd);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1092790">
 Parameter 
</A></H5>

<A NAME="1092796">
This function has the following parameter:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1092793">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1092795">
A pointer to a file descriptor for a connected SSL socket.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1092797">
 Returns
</A></H5>

<A NAME="1092798">
The function returns an integer:</A></P>
<ul><P><LI><A NAME="1092799">
If successful, the function returns the number of bytes waiting in internal SSL buffers for the specified socket.</A></LI>
<P><LI><A NAME="1092800">
If <CODE>SSL_SECURITY</CODE> has not been enabled with a call to <A HREF="sslfnc.html#1068466"><CODE>SSL_EnableDefault</CODE></A> or <A HREF="sslfnc.html#1086543"><CODE>SSL_Enable</CODE></A>, the function returns zero. </A></LI>
</ul><H5><A NAME="Head4;"></A>
<A NAME="1092801">
 Description
</A></H5>

<A NAME="1092802">
The <CODE>SSL_DataPending</CODE> function determines whether there is any received and decrypted application data remaining in the SSL socket's receive buffers after a prior read operation. This function does not reveal any information about data that has been received but has not yet been decrypted. Hence, if this function returns zero, that does not necessarily mean that a subsequent call to <A href="../../../../../../docs/refList/refNSPR/priofnc.html#543681" ><CODE>PR_Read</A></CODE> would block.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1092805">
 SSL_SecurityStatus
</A></H4>

<A NAME="1092806">
Gets information about the security parameters of the current connection. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1092807">
 Syntax
</A></H5>

<PRE><A NAME="1092808">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1092809">SECStatus SSL_SecurityStatus(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;int *on,<br>&nbsp;&nbsp;&nbsp;char **cipher,<br>&nbsp;&nbsp;&nbsp;int *keysize,<br>&nbsp;&nbsp;&nbsp;int *secretKeySize,<br>&nbsp;&nbsp;&nbsp;char **issuer,<br>&nbsp;&nbsp;&nbsp;char **subject);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1092810">
 Parameters
</A></H5>

<A NAME="1092858">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1092813">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1092815">
The file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1092817">
<CODE>on</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1092819">
A pointer to an integer. On output, the integer will be one of these values:</A></P><ul></P><LI><A NAME="1092820">
<CODE>SSL_SECURITY_STATUS_ OFF (= 0)</CODE></A></P><LI><A NAME="1092821">
<CODE>SSL_SECURITY_STATUS_ ON_HIGH (= 1)</CODE></A></P><LI><A NAME="1092822">
<CODE>SSL_SECURITY_STATUS_ON_LOW (= 2)</CODE></A></ul>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1092824">
<CODE>cipher</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1092826">
A pointer to a string pointer. On output, the string pointer references a newly allocated string specifying the name of the cipher. For SSL v2, the string is one of the following:</A></P><A NAME="1092827">
<CODE>RC4</CODE><P></A><A NAME="1092828">
<CODE>RC4-Export</CODE><P></A><A NAME="1092829">
<CODE>RC2-CBC</CODE><P></A><A NAME="1092830">
<CODE>RC2-CBC-Export</CODE><P></A><A NAME="1092831">
<CODE>DES-CBC</CODE><P></A><A NAME="1092832">
<CODE>DES-EDE3-CBC</CODE><P></A><P><A NAME="1092833">
</A></P><P><A NAME="1094891">
For SSL v3, the string is one of the following: </A></P><A NAME="1092834">
<CODE>RC4</CODE> <P></A><A NAME="1092835">
<CODE>RC4-40</CODE> <P></A><A NAME="1092836">
<CODE>RC2-CBC</CODE> <P></A><A NAME="1092837">
<CODE>RC2-CBC-40</CODE> <P></A><A NAME="1092838">
<CODE>DES-CBC</CODE> <P></A><A NAME="1092839">
<CODE>3DES-EDE-CBC</CODE> <P></A><A NAME="1123896">
<CODE>DES-CBC-40</CODE> <P></A><A NAME="1094640">
<CODE>FORTEZZA</CODE> <P></A>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1092843">
<CODE>keySize</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1092845">
A pointer to an integer. On output, the integer is the session key size used, in bits.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1092847">
<CODE>secretKeySize</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1092849">
A pointer to an integer. On output, the integer indicates the size, in bits, of the secret portion of the session key used (also known as the "effective key size"). The secret key size is never greater than the session key size.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1092851">
<CODE>issuer</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1115813">
A pointer to a string pointer. On output, the string pointer references a newly allocated string specifying the DN of the issuer of the certificate at the other end of the connection, in RFC1485 format. If no certificate is supplied, the string is "<CODE>no certificate</CODE>."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1092855">
<CODE>subject</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1092857">
A pointer to a string pointer specifying the distinguished name of the certificate at the other end of the connection, in RFC1485 format. If no certificate is supplied, the string is "<CODE>no certificate</CODE>."</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1092859">
 Returns
</A></H5>

<A NAME="1092860">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1092861">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1092864">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1092865">
 Description
</A></H5>

<A NAME="1115835">
The <CODE>SSL_SecurityStatus</CODE> function fills in values only if you supply pointers to values of the appropriate type. Pointers passed can be <CODE>NULL</CODE>, in which case the function does not supply values. When you are finished with them, you should free all the returned values using <A href="../../../../../../docs/refList/refNSPR/prmem.html#1020257" ><CODE>PR_Free</A></CODE>. </A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1092869">
 SSL_GetSessionID
</A></H4>

<A NAME="1092870">
Returns a <A HREF="ssltyp.html#1026076"><CODE>SECItem</CODE></A> structure containing the SSL session ID associated with a file descriptor.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1092871">
 Syntax
</A></H5>

<PRE><A NAME="1092872">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1092873">SECItem *SSL_GetSessionID(PRFileDesc *fd);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1092874">
 Parameter
</A></H5>

<A NAME="1092880">
This function has the following parameter:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1092877">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1092879">
A pointer to the file descriptor for the SSL socket.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1092881">
 Returns
</A></H5>

<A NAME="1092882">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1092883">
If successful, a pointer to <CODE>SECItem</CODE> structure containing the SSL session ID associated with the file descriptor passed in <CODE>fd</CODE>.</A></LI>
<A NAME="1092884">
If unsuccessful, <CODE>NULL</CODE>.<P></A></ul><H5><A NAME="Head4;"></A>
<A NAME="1149047">
 Description
</A></H5>

<A NAME="1149086">
This function returns a <A HREF="ssltyp.html#1026076"><CODE>SECItem</CODE></A> structure containing the SSL session ID associated with the file descriptor <CODE>fd</CODE>. When the application is finished with the <CODE>SECItem</CODE> structure returned by this function, it should free the structure by calling <CODE>SECITEM_FreeItem(item, PR_TRUE)</CODE>.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1124562">
 SSL_SetSockPeerID
</A></H4>

<A NAME="1124571">
Associates a peer ID with a socket to facilitate looking up the SSL session when it is tunneling through a proxy.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1124624">
 Syntax
</A></H5>

<PRE><A NAME="1124605">int SSL_SetSockPeerID(PRFileDesc *fd, char *peerID);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1124782">
 Parameters
</A></H5>

<A NAME="1124788">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1124785">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1124787">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1124825">
<CODE>peerID</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1124827">
An ID number assigned by the application to keep track of the SSL session associated with the peer.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1124789">
 Returns
</A></H5>

<A NAME="1124790">
The function returns one of these values: </A></P>
<ul><P><LI><A NAME="1124791">
If successful, zero.</A></LI>
<LI><A NAME="1124794">
If unsuccessful, -1. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1127887">
 Description
</A></H5>

<A NAME="1127890">
SSL peers frequently reconnect after a relatively short time has passed. To avoid the overhead of repeating the full SSL handshake in situations like this, the SSL protocol supports the use of a session cache, which retains information about each connection for some predetermined length of time. For example, a client session cache includes the hostname and port number of each server the client connects with, plus additional information such as the master secret generated during the SSL handshake. </A></P>
<A NAME="1128163">
For a direct connection with a server, the hostname and port number are sufficient for the client to identify the server as one for which it has an entry in its session cache. However, the situation is more complicated if the client is on an intranet and is connecting to a server on the Internet through a proxy. In this case, the client first connects to the proxy, and the client and proxy exchange messages specified by the proxy protocol that allow the proxy, in turn, to connect to the requested server on behalf of the client. This arrangement is known as SSL tunneling.</A></P>
<A NAME="1128016">
Client session cache entries for SSL connections that tunnel through a particular proxy all have the same hostname and port number--that is, the hostname and port number of the proxy. To determine whether a particular server with which the client is attempting to connect has an entry in the session cache, the session cache needs some additional information that identifies that server. This additional identifying information is known as a peer ID. The peer ID is associated with a socket, and must be set before the SSL handshake occurs--that is, before the SSL handshake is initiated by a call to a function such as <CODE><A href="../../../../../../docs/refList/refNSPR/priofnc.html#543681" >PR_Read</A></CODE> or <A HREF="sslfnc.html#1133431"><CODE>SSL_ForceHandshake</CODE></A>. To set the peer ID, you use <CODE>SSL_SetSockPeerID</CODE>.</A></P>
<A NAME="1128510">
In summary, SSL uses three pieces of information to identify a server's entry in the client session cache: the hostname, port number, and peer ID. In the case of a client that is tunneling through a proxy, the hostname and port number identify the proxy, and the peer ID identifies the desired server. Netscape recommends that the client set the peer ID to a string that consists of the server's hostname and port number, like this: "<CODE>www.hostname.com:387</CODE>". This convention guarantees that each server has a unique entry in the client session cache.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1128614">
 See Also
</A></H5>

<A NAME="1128636">
For information about configuring the session cache for a server, see <A HREF="sslfnc.html#1143851"><CODE>SSL_ConfigServerSessionIDCache</CODE></A>.</A></P>

<H2><A NAME="SSL Functions Used by Callbacks"></A>
<A NAME="1127893">
 SSL Functions Used by Callbacks
</A></H2><A NAME="1133491">
<A HREF="sslfnc.html#1096168"><CODE>SSL_PeerCertificate</CODE></A><br><A HREF="sslfnc.html#1081175"><CODE>SSL_RevealURL</CODE></A><br><A HREF="sslfnc.html#1123385"><CODE>SSL_RevealPinArg</CODE></A></A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1096168">
 SSL_PeerCertificate 
</A></H4>

<A NAME="1081216">
Returns a pointer to the certificate structure for the certificate received from the remote end of the SSL connection. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1081218">
 Syntax
</A></H5>

<PRE><A NAME="1081219">CERTCertificate *SSL_PeerCertificate(PRFileDesc *fd); </A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1081221">
 Parameter
</A></H5>

<A NAME="1081518">
This function has the following parameter:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1081511">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1081513">
A pointer to the file descriptor for the SSL socket.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1081226">
 Returns
</A></H5>

<A NAME="1081227">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1081642">
If successful, a pointer to a certificate structure.</A></LI>
<P><LI><A NAME="1081228">
If unsuccessful, <CODE>NULL</CODE>. </A></LI>
</ul><H5><A NAME="Head4;"></A>
<A NAME="1081229">
 Description
</A></H5>

<A NAME="1123398">
The <CODE>SSL_PeerCertificate</CODE> function is used by certificate authentication and bad-certificate callback functions to obtain the certificate under scrutiny. If the client calls <CODE>SSL_PeerCertificate</CODE>, it always returns the server's certificate. If the server calls <CODE>SSL_PeerCertificate</CODE>, it may return <CODE>NULL</CODE> if client authentication is not enabled or if the client had no certificate when asked. </A></P>
<A NAME="1136356">
SSL makes and keeps internal copies (or increments the reference counts, as appropriate) of certificate and key structures. The application should destroy its copies when it has no further use for them by calling <A HREF="sslcrt.html#1050532"><CODE>CERT_DestroyCertificate</CODE></A> and <A HREF="sslkey.html#1051017"><CODE>SECKEY_DestroyPrivateKey</CODE></A>. </A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1081175">
 SSL_RevealURL
</A></H4>

<A NAME="1081953">
Returns a pointer to a newly allocated string containing the domain name of the desired server. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1081955">
 Syntax
</A></H5>

<PRE><A NAME="1081956">char *SSL_RevealURL(PRFileDesc *fd); </A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1081958">
 Parameter
</A></H5>

<A NAME="1082262">
This function has the following parameter:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1082259">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1082261">
A pointer to the file descriptor for the SSL socket.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1081963">
 Returns
</A></H5>

<A NAME="1081964">
The function returns one of the following values:</A></P>
<ul><P><LI><A NAME="1082392">
If successful, returns a pointer to a newly allocated string containing the domain name of the desired server. </A></LI>
<P><LI><A NAME="1081966">
If unsuccessful, <CODE>NULL</CODE>. </A></LI>
</ul><H5><A NAME="Head4;"></A>
<A NAME="1081967">
 Description
</A></H5>

<A NAME="1123381">
The <CODE>SSL_RevealURL</CODE> function is used by certificate authentication callback function to obtain the domain name of the desired SSL server for the purpose of comparing it with the domain name in the certificate presented by the server actually contacted. When the callback function is finished with the string returned, the string should be freed with a call to <A href="../../../../../../docs/refList/refNSPR/prmem.html#1020257" ><CODE>PR_Free</A></CODE>.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1123385">
 SSL_RevealPinArg 
</A></H4>

<A NAME="1123386">
Returns the <CODE>PKCS11PinArg</CODE> value associated with the socket. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1081689">
 Syntax
</A></H5>

<PRE><A NAME="1081690">void *SSL_RevealPinArg(PRFileDesc *fd); </A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1081692">
 Parameter
</A></H5>

<A NAME="1081923">
This function has the following parameter:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1081920">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1081922">
A pointer to the file descriptor for the SSL socket.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1081924">
 Returns
</A></H5>

<A NAME="1081925">
The function returns one of the following values:</A></P>
<ul><P><LI><A NAME="1081926">
If successful, the <CODE>PKCS11PinArg</CODE> value associated with the socket. </A></LI>
<P><LI><A NAME="1081700">
If unsuccessful, <CODE>NULL</CODE>. </A></LI>
</ul><H5><A NAME="Head4;"></A>
<A NAME="1081945">
 Description
</A></H5>

<A NAME="1081702">
The <CODE>SSL_RevealPinArg</CODE> function is used by callback functions to obtain the PIN argument that NSS passes to certain functions. The PIN argument points to memory allocated by the application. The application is responsible for managing the memory referred to by this pointer. For more information about this argument, see <A HREF="sslfnc.html#1088040"><CODE>SSL_SetPKCS11PinArg</CODE></A>. </A></P>

<H2><A NAME="SSL Handshake Functions"></A>
<A NAME="1061582">
 SSL Handshake Functions
</A></H2><A NAME="1133419">
<A HREF="sslfnc.html#1133431"><CODE>SSL_ForceHandshake</CODE></A><br><A HREF="sslfnc.html#1043718"><CODE>SSL_RedoHandshake</CODE></A><br><A HREF="sslfnc.html#1058001"><CODE>SSL_ResetHandshake</CODE></A></A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1133431">
 SSL_ForceHandshake
</A></H4>

<A NAME="1023162">
Forces the handshake for a specified SSL socket to complete before any other action can take place. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1023163">
 Syntax
</A></H5>

<PRE><A NAME="1030069">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1023165">int SSL_ForceHandshake(PRFileDesc *fd);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1023166">
 Parameters
</A></H5>

<A NAME="1023172">
This function has the following parameter:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1023169">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1023171">
Pointer to the file descriptor for the SSL socket.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1023175">
 Returns
</A></H5>

<A NAME="1057843">
The function returns one of these values: </A></P>
<ul><P><LI><A NAME="1057844">
If successful, zero.</A></LI>
<LI><A NAME="1083148">
If unsuccessful, <CODE>-1</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code. 
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1083120">
 Description
</A></H5>

<A NAME="1083121">
When you are forcing the initial handshake, this function returns when the handshake is complete. For subsequent handshakes, the function can return either because the handshake is complete, or because application data has been received on the connection that must be processed (that is, the application must read it) before the handshake can continue. If the socket is a blocking socket, the function does not return until the SSL handshake is complete. </A></P>
<A NAME="1143675">
In versions prior to NSS 1.2, you cannot force a subsequent handshake. If you use this function after the initial handshake, it returns immediately without forcing a handshake.</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1043718">
 SSL_RedoHandshake
</A></H4>

<A NAME="1043719">
Causes SSL to perform a full, new SSL 3.0 handshake from scratch. </A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1043720">
 Syntax
</A></H5>

<PRE><A NAME="1043721">#include &lt;ssl.h&gt;<br>#include &lt;prio.h&gt;<br>#include &lt;seccomon.h&gt;</A></PRE><PRE><A NAME="1043722">int SSL_RedoHandshake(PRFileDesc *fd);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1043723">
 Parameter
</A></H5>

<A NAME="1043729">
This function has the following parameter:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1043726">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1043728">
A pointer to the file descriptor for the SSL socket.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1070253">
 Returns
</A></H5>

<A NAME="1070254">
The function returns one of these values: </A></P>
<ul><P><LI><A NAME="1070255">
If successful, zero.</A></LI>
<LI><A NAME="1070258">
If unsuccessful, -1. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1070289">
 Description
</A></H5>

<A NAME="1070290">
The SSL_RedoHandshake function removes the current SSL session from the session cache and starts another full SSL 3.0 handshake. It is for use with SSL 3.0 only. You can call this function to redo the handshake if you have changed one of the socket's configuration parameters (for example, if you are going to request client authentication).</A></P>

<H4><A NAME="Head3;"></A>
<A NAME="1058001">
 SSL_ResetHandshake
</A></H4>

<A NAME="1058002">
Resets the handshake state for a specified socket.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1050115">
 Syntax
</A></H5>

<PRE><A NAME="1060857">#include &lt;ssl.h&gt; </A></PRE><PRE><A NAME="1057923">SECStatus SSL_ResetHandshake(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRBool asServer);</A></PRE><H5><A NAME="Head4;"></A>
<A NAME="1057929">
 Parameters
</A></H5>

<A NAME="1057935">
This function has the following parameters:<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1057932">
<CODE>fd</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1057934">
A pointer to the file descriptor for the SSL socket.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1057956">
<CODE>asServer</CODE></A></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1070325">
A Boolean value. <CODE>PR_TRUE</CODE> means the socket will attempt to handshake as a server the next time it tries, and <CODE>PR_FALSE</CODE> means the socket will attempt to handshake as a client the next time it tries.</A></P>

</TABLE>
</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1058067">
 Returns
</A></H5>

<A NAME="1058068">
The function returns one of these values:</A></P>
<ul><P><LI><A NAME="1058069">
If successful, <CODE>SECSuccess</CODE>.</A></LI>
<LI><A NAME="1058072">
If unsuccessful, <CODE>SECFailure</CODE>. Use <A href="../../../../../../docs/refList/refNSPR/prerr.html#1035678" ><CODE>PR_GetError</A></CODE> to obtain the error code.
</A></LI></ul><H5><A NAME="Head4;"></A>
<A NAME="1057927">
 Description
</A></H5>

<A NAME="1070424">
Calling <CODE>SSL_ResetHandshake</CODE> causes the SSL handshake protocol to start from the beginning on the next I/O operation. That is, the handshake starts with no cipher suite already in use, just as it does on the first handshake on a new socket. </A></P>

<H2><A NAME="NSS Shutdown Function"></A>
<A NAME="1095840">
 NSS Shutdown Function
</A></H2>
<H4><A NAME="Head3;"></A>
<A NAME="1061858">
 NSS_Shutdown
</A></H4>

<A NAME="1095826">
Closes the key and certificate databases that were opened by <A HREF="sslfnc.html#1067601"><CODE>NSS_Init</CODE></A>.</A></P>
<H5><A NAME="Head4;"></A>
<A NAME="1095828">
 Syntax
</A></H5>

<PRE><A NAME="1095832">#include &lt;nss.h&gt;</A></PRE><PRE><A NAME="1095836">void NSS_Shutdown(void);</A></PRE>
<HR>

<FONT SIZE=-1><A HREF="index.html">Table of Contents</A> | <A HREF="ssltyp.html">Previous</A>
 | <A HREF="sslcrt.html">Next</A>
 | <A HREF="bklast.html">Index</A>
</FONT>
<P ALIGN=right>
<FONT SIZE=-2><I>Last Updated:  01/17/00  16:36:30</I></FONT>
<P> 






</TD>

</TR>
<TR>

<TD COLSPAN="2" ALIGN="RIGHT" VALIGN="TOP">
<FONT SIZE="-1">
Copyright &copy; 1998-2000 The Mozilla Organization.
<BR>
<A HREF="http://www.mozilla.org/webtools/bonsai/cvslog.cgi?file=mozilla-org/html/projects/security/pki/nss/ref/ssl/sslfnc.html&amp;rev=&amp;root=/cvsroot/">Last modified January 18,  2000</A>.
</FONT>
</TD>
</TR>

</TABLE>
</BODY>
</HTML>
