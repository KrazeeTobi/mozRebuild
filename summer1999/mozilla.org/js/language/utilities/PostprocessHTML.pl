#!/usr/bin/perl -w
# Waldemar Horwat
# Netscape
#
# PostProcessHTML [-n] (dir ... dir | -summarize srcfile dstfile)
#
# If the first option is -n, don't write the files.
# If dir's is given, postprocess all html files in the given directories (including subdirectories).
# If -summarize is given, coalesce all files referred from srcfile's CONTENTS into dstfile.

use 5.004;
use strict;
use diagnostics;
use Cwd "cwd";
use File::Basename;
use File::Copy;
use File::Find;
use POSIX;

my $onMac = "\n" eq "\015";
require "MacUtilities.pl" if $onMac;


my $printElementHierarchy = 0; # Set to print the hierarchy of the elements in the file

# Files that are to be examined before other files in the same directory.
my %indexFiles = ("index.html" => -10, "futures.html" => -9);


my $sep = "/"; # file path separator
my $pre = "";  # relative path prefix

if ($onMac) {
    $sep = ":";
    $pre = ":";
}


my $noSet = 0;


# Return true if the two arrays are equal.
sub arrayEq(\@\@) {
	my ($a1, $a2) = @_;
	my $len = scalar @$a1;
	return "" if $len != scalar @$a2;
	for (my $i = 0; $i != $len; $i++) {
		return "" if $$a1[$i] ne $$a2[$i];
	}
	return 1;
}


# Return a hash table containing the given keys and "true" values.
sub listToHash(@) {
	my %h;
	foreach (@_) {
		die "Duplicate entry: ", $_ if $h{$_};
		$h{$_} = 1;
	}
	return %h;
}


# Return the date nicely formatted.
sub formatDate(@) {
	return POSIX::strftime("%A, %B ", @_) . $_[3] . ", " . (1900+$_[5]);
}


# Convert the given pathname to an absolute pathname.
sub pathToAbsolute($) {
	($_) = @_;
	if ($onMac) {
		$_ = ":".$_ if index($_, ':') == -1;
		$_ = cwd . $_ if substr($_, 0, 1) eq ':';
		while (s/:[^:]+::/:/) {}
	} else {
		$_ = $_ . "/" if (/(^|\/)\.\.?$/);
		if ($_ eq "./") {
			$_ = cwd;
		} elsif (substr($_, 0, 1) ne '/') {
			$_ = cwd . "/" . $_;
			while (s|/[^./][^/]*/../|/|) {}
		}
	}
	return $_;
}


# Elements with no end tags
my %singletonElements = listToHash "AREA", "BASE", "BASEFONT", "BR", "COL", "FRAME", "HR", "IMG", "INPUT",
	"ISINDEX", "LINK", "META", "PARAM";

my @inlineElementList = ("TT", "I", "B", "U", "S", "STRIKE", "BIG", "SMALL", "EM", "STRONG", "DFN", "CODE",
	"SAMP", "KBD", "VAR", "CITE", "ABBR", "ACRONYM", "A", "IMG", "APPLET", "OBJECT", "FONT", "BASEFONT", "BR", "SCRIPT",
	"MAP", "Q", "SUB", "SUP", "SPAN", "BDO", "IFRAME", "INPUT", "SELECT", "TEXTAREA", "LABEL", "BUTTON");
my %inlineElements = listToHash @inlineElementList;
my %flowElements = listToHash "P", "H1", "H2", "H3", "H4", "H5", "H6", "UL", "OL", "DIR", "MENU", "PRE", "DL",
	"DIV", "CENTER", "NOSCRIPT", "NOFRAMES", "BLOCKQUOTE", "FORM", "ISINDEX", "HR", 
	"TABLE", "FIELDSET", "ADDRESS", @inlineElementList;
my %trElement = listToHash "TR";
my %possiblyEmptyElements = listToHash "A", "BODY", "SCRIPT", "TD", "TH";
my %okToRemoveEmptyElements = listToHash "TT", "I", "B", "U", "S", "STRIKE", "BIG", "SMALL", "EM", "STRONG", "DFN", "CODE",
	"SAMP", "KBD", "VAR", "CITE", "ABBR", "ACRONYM", "FONT", "SCRIPT", "SUB", "SUP", "SPAN",
	"P", "H1", "H2", "H3", "H4", "H5", "H6", "DIV";
my %okToRemoveSpacesInside = listToHash "P", "H1", "H2", "H3", "H4", "H5", "H6", "UL", "OL", "DIR", "MENU", "DL",
	"DIV", "TABLE", "ADDRESS", "TD", "TH", "TR", "LI";
my %okToRemoveSpacesAround = listToHash "BR", "HR";

# Elements with optional end tags.  The values are hash-lists of allowed nested tags.
my %selfTerminatingElements = (
	COLGROUP => {listToHash("COL")},
	DD => \%flowElements,
	DT => \%inlineElements,
	HEAD => {listToHash "TITLE", "ISINDEX", "BASE", "SCRIPT", "STYLE", "META", "LINK", "OBJECT"},
	HTML => {listToHash "HEAD", "BODY"},
	LI => \%flowElements,
	OPTION => {},
	P => \%inlineElements,
	TBODY => \%trElement,
	TFOOT => \%trElement,
	THEAD => \%trElement,
	TD => \%flowElements,
	TH => \%flowElements,
	TR => {listToHash "TD", "TH"});

# Attributes whose values should always be quoted.
my %alwaysQuotedAttributes = listToHash "alt", "href", "name";


# Find all files in the given directory (including subdirectories) with the given suffix.
# Return a list of the files' full pathnames.
sub findFiles($$) {
    my ($dirName, $suffix) = @_;

	my @files;
	find(sub {push @files, $File::Find::name if (/\.$suffix$/)}, $dirName);
	return @files;
}


# Given a pathname, return a unique generated pathname for a new backup file and, if on
# a Macintosh, a dirID of the given pathname.  The new name is
# generated by appending "~N" with the smallest nonnegative integer N to the pathname
# while still keeping the length of the filename below 32 characters.
#
# On the Macintosh the backup files are put in the trash folder on the volume given by the
# pathname.
sub genBackupFileName($) {
	my ($pathName) = @_;
	my ($name, $path) = fileparse $pathName;
	my $backupPath = $path;
	my $dirID;
	($backupPath, $dirID) = getTrashFolder($pathName) if $onMac;
	
	my $i = 0;
	while (1) {
		my $ending = "~$i";
		my $tempPathName = $backupPath . substr($name, 0, 31 - length $ending) . $ending;
		return ($tempPathName, $dirID) unless -e $tempPathName;
		$i++;
	}
}


# Back up the given files.
sub backUpFile(@) {
	foreach (@_) {
		my ($backupPathName, $dirID) = genBackupFileName $_;
		print "$_ --> $backupPathName\n";
		copy $_, $backupPathName or die $^E;
		setPutAway($backupPathName, $dirID) if $onMac;
	}
}


# Back up the given file and then update its contents to be the given list.
# Set the file's modification date one minute after its previous value.
sub updateFile($@) {
	my $pathName = shift;
	if ($noSet) {
		print STDERR "***** File $pathName not written due to -n\n";
	} else {
		backUpFile $pathName;
		my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks) =
			stat $pathName or die $^E;
		open DSTFILE, ">".$pathName or die $^E;
		print DSTFILE @_;
		close DSTFILE or die $^E;
		my $now = time;
		$mtime += 60;
		if ($mtime <= $now) {
			utime time, $mtime, $pathName or die $^E;
		}
	}
}


my $currentPathName;
my $changed;
my $nWarnings = 0;

sub alertChange(@) {
	print STDERR "\nIn '", $currentPathName, "':\n" unless $changed;
	$changed = 1;
	print STDERR @_, "\n";
}


sub warning(@) {
	print STDERR "***** WARNING: ", @_, "\n";
	$nWarnings++;
}


# Read a file with the given file or path name.  Strip trailing whitespace from each line.
# Return the file as a list of lines.
sub fetchFile($) {
	($currentPathName) = @_;
	
	$changed = 0;
	open SRCFILE, "<".$currentPathName or die $^E;

	my $nModifiedLines = 0;
	my @lines;
	while (<SRCFILE>) {
		$nModifiedLines += s/[ \t]+$//;
		push @lines, $_;
	}
	close SRCFILE or die $^E;
	alertChange "Removed trailing whitespace on $nModifiedLines lines" if $nModifiedLines;
	return @lines;
}


# Given a list of lines, each ending with a newline except maybe the last, parse
# it into a list of runs.  Each run is either plain text or an HTML comment,
# tag (opening or closing), or directive.  Return the list of runs.
# If $replaceQuots is true, replace &quot; with " except inside scripts or tags.
sub parseTags($@) {
	my $replaceQuots = shift;
	my @runs;
	my $textRun = "";
	my $nQuots;
	$_ = "";
	while (1) {
		my $pos = index $_, "<";
		if ($pos == -1) {
			$textRun .= $_;
			$_ = shift || last;
		} else {
			$textRun .= substr $_, 0, $pos;
			$_ = substr $_, $pos;
			if ($textRun ne "") {
				die "> should be &gt; in: ", $textRun if index($textRun, ">") != -1;
				$nQuots += $textRun =~ s/&quot;/"/gs if $replaceQuots;
				push @runs, $textRun;
				$textRun = "";
			}
			
			my $markup;
			while (1) {
				if (($markup) = /^(<(?:![ \t]*--.*?--[ \t]*|\/?[:0-9A-Za-z]+[^<>]*|![0-9A-Za-z\[][^<>]*)>)/s) {
					push @runs, $markup;
					$_ = substr $_, length $markup;
					last;
				} elsif (/^<(?:![ \t]*--|\/?[:0-9A-Za-z]+|![0-9A-Za-z\[])/) {
					$_ .= shift || die "Unterminated tag: ", $_;
				} else {
					die "Unknown markup: ", $_;
				}
			}
			
			if ($markup =~ /^<SCRIPT/i) {
				while (($pos = index $_, "</") == -1) {
					$textRun .= $_;
					$_ = shift || die "Unterminated script: ", $textRun, $_;
				}
				$textRun .= substr $_, 0, $pos;
				if ($textRun ne "") {
					die "Script shouldn't begin with a < in: ", $textRun if substr($textRun, 0, 1) eq "<" and substr($textRun, 1, 1) ne "!";
					push @runs, $textRun;
					$textRun = "";
				}
				$_ = substr $_, $pos;
			}
		}
	}
	if ($textRun ne "") {
		die "> should be &gt; in: ", $textRun if index($textRun, ">") != -1;
		$nQuots += $textRun =~ s/&quot;/"/gs if $replaceQuots;
		push @runs, $textRun;
		$textRun = "";
	}
	alertChange "Replaced $nQuots occurrences of &quot; with double quotes" if $nQuots;
	return @runs;
}


# Given a list of runs, convert attributes in each tag to a canonical format:
#   Tag names in upper case;
#   Attribute names in lower case;
#   Attribute values quoted with double quotes unless consist only of alphanumerics or _ or -;
#   Attributes separated by one space
# Return the list of runs, which is modified in place.
sub cleanAttributes(@) {
	my $nModifiedTags = 0;
	foreach (@_) {
		if (/^<[\/:0-9A-Za-z]/ && !/^<\/?[:0-9A-Z]+( [-:a-z]+(=([-0-9A-Za-z]+|"[^<>"]*[^-0-9A-Za-z<>"][^<>"]*"))?)*>/) {
			my ($tagName,$args) = /^<(\/?[:0-9A-Za-z]+)([^<>]*?)\s*>$/ or die "Bad attributes: ", $_;
			$tagName = uc $tagName;
			my $newTag = "<" . $tagName;
			while ($args ne "") {
				my ($key, $value, $rest) = $args =~ /^\s+([-:0-9A-Za-z]+)(?:\s*=\s*([-0-9A-Za-z._]+|'[^<>']*'|"[^<>"]*"))?(.*)$/s
					or die "Bad attributes ($args) in: ", $_;
				$key = lc $key;
				$newTag .= " " . $key;
				if (defined $value) {
					if ($value =~ /^'(.*)'$/s) {
						$value = $1;
						$value =~ s/"/&quot;/g;
					}
					elsif ($value =~ /^"(.*)"$/s) {$value = $1;}
					$value = '"'.$value.'"' if $value !~ /^[-0-9A-Za-z]+$/ || $alwaysQuotedAttributes{$key};
					$newTag .= "=".$value;
				}
				$args = $rest;
			}
			$newTag .= ">";
			if ($_ ne $newTag) {
				$nModifiedTags++;
				$_ = $newTag;
			}
		}
	}
	alertChange "Reformatted $nModifiedTags tags" if $nModifiedTags;
	return @_;
}


# Given a list of runs, insert all optional closing tags.
# Return the list of runs, which is modified in place.
sub closeTags(\@) {
	my ($runs) = @_;
	my @stack;	# Tags opened but not yet closed
	my $i;
	my %insertedTags;

	my $addClosingTag = sub {
		my ($closingTagName) = @_;
		my $closingTag = "</" . $closingTagName . ">";
		if ($i && $$runs[$i-1] =~ /^(.*?)(\s+)$/s) {
			if ($1 eq "") {
				splice @$runs, $i-1, 0, $closingTag;
				$i++;
			} else {
				splice @$runs, $i-1, 1, $1, $closingTag, $2;
				$i += 2;
			}
		} else {
			splice @$runs, $i, 0, $closingTag;
			$i++;
		}
		$insertedTags{$closingTag} = 1;
	};

	for ($i = 0; $i <= $#$runs; $i++) {
		if ($$runs[$i] =~ /^<(\/?)([0-9A-Za-z]+)/) {
			my $isClose = $1;
			my $tagName = $2;
			if ($isClose) {
				while (1) {
					my $prevTag = pop @stack or die "Closing tag without opening tag: ", $$runs[$i];
					last if $prevTag eq $tagName;
					die "Tag ", $$runs[$i], " trying to close ", $prevTag unless $selfTerminatingElements{$prevTag};
					$addClosingTag->($prevTag);
				}
				print "  "x@stack, "/", $tagName, "\n" if $printElementHierarchy;
			} else {
				while (@stack) {
					my $allowedChildren = $selfTerminatingElements{$stack[$#stack]};
					last unless $allowedChildren && !$$allowedChildren{$tagName};
					$addClosingTag->(pop @stack);
				}
				print "  "x@stack, $tagName, "\n" if $printElementHierarchy;
				push @stack, $tagName unless $singletonElements{$tagName};
			}
		}
	}
	while (@stack) {
		my $prevTag = pop @stack;
		die "Unclosed tag: ", $prevTag unless $selfTerminatingElements{$prevTag};
		$addClosingTag->($prevTag);
	}
	alertChange "Inserted tags ", join ", ", sort keys %insertedTags if %insertedTags;
	return @$runs;
}


# Given a list of runs, warn about empty elements that do not appear in %possiblyEmptyElements.
# Remove empty elements that appear in %okToRemoveEmptyElements.
sub warnOfEmptyElements(\@) {
	my ($runs) = @_;
	my $i;
	my $currentTag = "";
	my $blank;
	my $line = 1;

	for ($i = 0; $i <= $#$runs; $i++) {
		$_ = $$runs[$i];
		if (/^<(\/?)([0-9A-Za-z]+)/) {
			if ($1) {
				if ($currentTag eq $2 && !$possiblyEmptyElements{$currentTag}) {
					if (!$blank && $okToRemoveEmptyElements{$currentTag}) {
						alertChange "Removed empty tag $currentTag on line $line";
						splice @$runs, $i-1, 2;
						$i -= 2;
					} else {
						warning $blank ? "Blank" : "Empty", " tag $currentTag on line $line in $currentPathName";
					}
				}
				$currentTag = "";
			} else {
				$currentTag = $2;
				$blank = 0;
			}
		} elsif (/^\s*$/) {
			$blank = 1;
		} else {
			$currentTag = "";
		}
		$line++ while (/\n/g);
	}
	return @$runs;
}


# If the $i-th element of $runs is an opening or closing tag, return a list consisting of:
#   either "" or "/" depending on whether the tag opens or closes;
#   the name of the tag.
# If not, return a list consisting of "?" and "".
sub decodeTag(\@$) {
	my ($runs, $i) = @_;
	if ($i >= 0 && $i <= $#$runs && $$runs[$i] =~ /^<(\/?)([0-9A-Za-z]+)/) {
		return ($1, $2);
	}
	return ("?", "");
}


# Given a list of runs, warn about spaces after opening tags or before closing tags.
# Remove spaces after opening tags or before closing tags that appear in %okToRemoveSpacesInside.
# Remove spaces before or after tags that appear in %okToRemoveSpacesAround.
sub warnOfSpaces(\@) {
	my ($runs) = @_;
	my $i;
	my $prevSlash;
	my $prevTag;
	my $nextSlash;
	my $nextTag;
	my $nonBlank;
	my $line = 1;

	for ($i = 0; $i <= $#$runs; $i++) {
		$_ = $$runs[$i];
		if (/^[ \t]+$/) {
			($prevSlash, $prevTag) = decodeTag @$runs, $i-1;
			($nextSlash, $nextTag) = decodeTag @$runs, $i+1;
			if ($prevSlash eq "" && ($okToRemoveSpacesInside{$prevTag} || $okToRemoveSpacesAround{$prevTag})) {
				alertChange "Removed spaces after tag ", $$runs[$i-1], " on line $line";
				splice @$runs, $i, 1;
				$_ = "";
				$i--;
			} elsif ($nextSlash eq "" ? $okToRemoveSpacesAround{$nextTag} : $okToRemoveSpacesInside{$nextTag}) {
				alertChange "Removed spaces before tag ", $$runs[$i+1], " on line $line";
				splice @$runs, $i, 1;
				$_ = "";
				$i--;
			} elsif ($prevSlash ne "/" || $nextSlash ne "") {
				warning "Extra spaces on line $line in $currentPathName: '", $$runs[$i-1], "','", $_, "','", $$runs[$i+1], "'";
			}
		} else {
			if (($nonBlank) = /^[ \t]+([^ \t].*)$/s) {
				($prevSlash, $prevTag) = decodeTag @$runs, $i-1;
				if ($prevSlash eq "" && ($okToRemoveSpacesInside{$prevTag} || $okToRemoveSpacesAround{$prevTag})) {
					alertChange "Removed spaces after tag ", $$runs[$i-1], " on line $line";
					$$runs[$i] = $nonBlank;
					$_ = $nonBlank;
				} elsif ($prevSlash ne "/") {
					warning "Extra spaces on line $line in $currentPathName: '", $$runs[$i-1], "','", $_, "'";
				}
			}
			if (($nonBlank) = /^(.*\S)[ \t]+$/s) {
				($nextSlash, $nextTag) = decodeTag @$runs, $i+1;
				if ($nextSlash eq "" ? $okToRemoveSpacesAround{$nextTag} : $okToRemoveSpacesInside{$nextTag}) {
					alertChange "Removed spaces before tag ", $$runs[$i+1], " on line $line";
					$$runs[$i] = $nonBlank;
					$_ = $nonBlank;
				} elsif ($nextSlash ne "") {
					warning "Extra spaces on line $line in $currentPathName: '", $_, "','", $$runs[$i+1], "'";
				}
			}
		}
		$line++ while (/\n/g);
	}
	return @$runs;
}


# Update the modification dates based on the given date
sub updateModDate($@) {
	my $newModDate = shift;
	my $newDateString = formatDate localtime $newModDate;
	my $nDatesFound = 0;
	my $nDatesChanged = 0;
	foreach (@_) {
		if ((/^<ADDRESS[>\s]/i ... /^<\/ADDRESS>/i) ||
			(/^<P\s.*class\s*=\s*['"]?mod-date['"]?[>\s]/si ... /^<\/P>/i)) {
			if (substr($_, 0, 1) ne "<" &&
				/\b([A-Za-z]+day,\s+[A-Za-z]+\s+\d{1,2},\s+\d{4})\b/i) {
				$nDatesFound++;
				if ($1 ne $newDateString) {
					s/[A-Za-z]+day,\s+[A-Za-z]+\s+\d{1,2},\s+\d{4}/$newDateString/i;
					$nDatesChanged++;
				}
			}
		}
	}
	warning "Found $nDatesFound dates in $currentPathName" if $nDatesFound != 2;
	alertChange "Updated $nDatesChanged dates to $newDateString" if $nDatesChanged;
	return @_;
}


my %prevLinks;  #<full-pathname> -> <full-pathname> of previous page
my %nextLinks;  #<full-pathname> -> <full-pathname> of next page
my %startLinks; #<full-pathname> -> <full-pathname> of contents and start page
my %upLinks;    #<full-pathname> -> <full-pathname> of referring page

my %linkKinds = (
	"Lprev" => \%prevLinks,
	"Lnext" => \%nextLinks,
	"Lstart" => \%startLinks,
	"Lcontents" => \%startLinks,
	"Aleft" => \%prevLinks,
	"Aright" => \%nextLinks,
	"Aup" => \%upLinks);


# Update the hash to the given value.  The hash must be either undefined or eq to
# the given value.
sub updateHash(\%$$) {
	my ($hash, $key, $value) = @_;
	die "Changing ", $key, ": ", $$hash{$key}, " -> ", $value if
		defined($$hash{$key}) && $$hash{$key} ne $value;
	$$hash{$key} = $value;
}


# Look up the link of the given kind from the given pathname.  Return the relative link
# as a unix-style relative path or undefined if there is no link given.
sub lookupLink($$) {
	my ($linkKind, $pathName) = @_;
	my $dstPathName = $linkKinds{$linkKind}{$pathName};
	return undef if !defined $dstPathName;
	my ($srcName, $srcPath) = fileparse $pathName;
	my ($dstName, $dstPath) = fileparse $dstPathName;
	while ($srcPath ne $dstPath) {
		if ($srcPath =~ /^(.+)$sep/) {
			($srcName, $srcPath) = fileparse $1;
			$dstName = "../" . $dstName;
		} else {
			die "Cross-directory links not supported yet";
		}
	}
	return $dstName;
}



# Given a list of runs of an index file, update the %prevLinks, %nextLinks, %startLinks and
# %upLinks hash tables based on the file's contents between the CONTENTS and /CONTENTS
# or DOWN and /DOWN HTML comments.
sub readTableOfContents($@) {
	my $pathName = shift;
	my ($fileName, $dir) = fileparse $pathName;

	my $prev = $pathName;
	foreach (@_) {
		if (/^<!--\s*CONTENTS\s*-->/i ... /^<!--\s*\/CONTENTS\s*-->/i) {
			if (/^<A\s+href="([^"<>.\/][^"<>]*\.html)">$/) {
				my $ref = $1;
				$ref =~ s|/|$sep|g;
				$ref = $dir . $ref;
				# print "CONTENTS: $ref\n";
				if (defined $prev) {
					updateHash %nextLinks, $prev, $ref;
					updateHash %prevLinks, $ref, $prev;
					updateHash %startLinks, $ref, $pathName;
					updateHash %upLinks, $ref, $pathName;
				}
				$prev = $ref;
			}
		}
		if (/^<!--\s*DOWN\s*-->/i ... /^<!--\s*\/DOWN\s*-->/i) {
			if (/^<A\s+href="([^"<>.\/][^"<>]*\.html)">$/) {
				my $ref = $1;
				$ref =~ s|/|$sep|g;
				$ref = $dir . $ref;
				# print "DOWN: $ref\n";
				updateHash %upLinks, $ref, $pathName;
			}
		}
	}
	return @_;
}


# Update a file's links and arrow-image anchors based on the %prevLinks, %nextLinks, %startLinks and
# %upLinks values.
sub updateLinks($@) {
	my $pathName = shift;
	if ($pathName !~ /-old\.html$/) {
		my $nLinks = 0;
	
		foreach (@_) {
			if (my ($pre, $linkKind, $href, $post) = /^(<LINK\s+rel=['"]?(Start|Contents|Prev|Next)['"]?\s+href=")([^"<>]*)("[>\s].*)$/is) {
				$nLinks++;
				$linkKind = lc $linkKind;
				my $newHRef = lookupLink "L".$linkKind, $pathName;
				if (!defined $newHRef) {
					warning "No $linkKind link specified from $pathName";
				} elsif ($newHRef ne $href) {
					$_ = $pre . $newHRef . $post;
					alertChange "Updated $linkKind link from \"$href\" to \"$newHRef\"";
				}
			}
			last if $_ eq "<BODY>";
		}
		
		my $i = 0;
		my $limit = scalar(@_) - 2;
		while ($i < $limit) {
			if (my ($pre, $href, $post) = $_[$i] =~ /^(<A\s+href=")([^"<>]*)("[>\s].*)$/is and
				my ($arrowKind) = $_[$i+1] =~ /^<IMG\s+src="[^"<>]*arrows\/([^"<>\/]*)\.gif"/is and
				uc $_[$i+2] eq "</A>") {
				$nLinks++;
				my $newHRef = lookupLink "A".$arrowKind, $pathName;
				if (!defined $newHRef) {
					warning "No $arrowKind arrow link specified from $pathName";
				} elsif ($newHRef ne $href) {
					$_[$i] = $pre . $newHRef . $post;
					alertChange "Updated $arrowKind arrow link from \"$href\" to \"$newHRef\"";
				}
			}
			$i++;
		}
	
		my $nLinksExpected = 0;
		foreach my $links (values %linkKinds) {
			$nLinksExpected++ if defined $$links{$pathName};
		}
	
		warning "Expected $nLinksExpected and found $nLinks links in $pathName" if $nLinks != $nLinksExpected;
	}
	return @_;
}


my %noWrapDirectories; # Hash table of directory -> list of files to not be wrapped in that directory

# Record the file in %noWrapDirectories if it contains any LINK, SCRIPT, or STYLE in its head section.
sub recordNoWrap($@) {
	my $pathName = shift;
	if ($pathName !~ /-old\.html$/) {
		foreach (@_) {
			if (/^<(LINK|SCRIPT|STYLE)[>\s]/is) {
				my ($srcName, $srcPath) = fileparse $pathName;
				push @{$noWrapDirectories{$srcPath}}, $srcName;
				last;
			}
			last if $_ eq "<BODY>";
		}
	}
	return @_;
}


# Return the NOWRAP file in the given directory as a list.  Return the empty list if there
# is no NOWRAP file there.  Also initialize $changed and $currentPathName.
sub readNoWrap($) {
	my ($path) = @_;

	$changed = 0;
	$currentPathName = $path . "NOWRAP";
	return () unless -f $currentPathName;
	open NOWRAPFILE, "<".$currentPathName or die $^E;
	my @noWrapFiles;
	while (<NOWRAPFILE>) {
		if (/^\s*([^:\/\n\r]+)\s*$/) {
			push @noWrapFiles, $1;
		} else {
			die "Bad NOWRAP line: $_";
		}
	}
	close NOWRAPFILE or die $^E;
	return @noWrapFiles;
}


# Ensure that all entries in %noWrapDirectories are present in NOWRAP files.  Update the NOWRAP files
# as appropriate.
sub processNoWrapRequests() {
	while (my ($path, $requiredNoWrapFiles) = each %noWrapDirectories) {
		# print "$path:  ", join(", ", @$requiredNoWrapFiles), "\n";
		my @oldNoWrapFiles = readNoWrap($path);
		my %newNoWrapFiles = listToHash @oldNoWrapFiles;
		foreach (@oldNoWrapFiles) {
			unless (-f $path.$_) {
				alertChange "File $_ doesn't exist";
				delete $newNoWrapFiles{$_};
			}
		}
		foreach (@$requiredNoWrapFiles) {
			unless ($newNoWrapFiles{$_}) {
				$newNoWrapFiles{$_} = 1;
				alertChange "Added $_";
			}
		}
		my @newNoWrapFiles = sort keys %newNoWrapFiles;
		alertChange "Sorted files" unless $changed || arrayEq @oldNoWrapFiles, @newNoWrapFiles;
		if ($changed) {
			if ($noSet) {
				print STDERR "***** File $currentPathName not written due to -n\n";
			} else {
				backUpFile $currentPathName if -f $currentPathName;
				open DSTFILE, ">".$currentPathName or die $^E;
				foreach (@newNoWrapFiles) {
					print DSTFILE $_, "\n";
				}
				close DSTFILE or die $^E;
			}
		}
	}
}


sub orderPaths {
	my ($aName, $aDir) = fileparse $a;
	my ($bName, $bDir) = fileparse $b;
	return $aDir cmp $bDir
		|| ($indexFiles{$aName} || 0) <=> ($indexFiles{$bName} || 0)
		|| $aName cmp $bName;
}

sub processDirectory($) {
	my ($dirName) = @_;
	$dirName = pathToAbsolute $dirName;
	foreach my $f (sort orderPaths findFiles $dirName, "html") {
		# print ">$f\n";
		my @file = fetchFile $f;
		my @runs = parseTags 1, @file;
		if ($runs[0] =~ /^<!DOCTYPE\s/i) {
			cleanAttributes @runs;
			closeTags @runs;
			warnOfEmptyElements @runs;
			warnOfSpaces @runs;
			recordNoWrap $f, @runs;
			readTableOfContents $f, @runs if $indexFiles{basename $f};
		} else {
			warning "File $f doesn't start with <!DOCTYPE>";
		}
		my $fileModDate = (stat $f)[9] or die $^E;
		updateModDate $fileModDate, @runs;
		updateLinks $f, @runs;
		# print "------------\n", @runs;
		if ($changed) {
			updateFile $f, @runs;
		}
	}
}


sub summarizeFile($$) {
	my ($f, $dstF) = @_;
	my @file = fetchFile $f;
	my @runs = parseTags 1, @file;
	cleanAttributes @runs;
	readTableOfContents $f, @runs;
	while (defined $f) {
		print "File: $f\n";
		$f = $nextLinks{$f}
	}
}


if (scalar(@ARGV) && $ARGV[0] eq "-n") {
	$noSet = 1;
	shift;
}
if (scalar(@ARGV) && $ARGV[0] eq "-summarize") {
	shift;
	die "Need source and destination files for -summarize" unless scalar(@ARGV) == 2;
	summarizeFile($ARGV[0], $ARGV[1]);
} else {
	warning "Nothing to do" unless @ARGV;
	foreach my $srcDir (@ARGV) {
		processDirectory($srcDir);
	}
}
processNoWrapRequests;
print STDERR "\n***** ", $nWarnings, " warnings\n" if $nWarnings;

1;
