<HTML><HEAD>   <META NAME="Author" CONTENT="Will Scullin">   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 (Macintosh; I; PPC) [Netscape]">   <TITLE>Modularization Techniques</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><H1>Modularization Techniques</H1></CENTER><CENTER><I>Rough Draft</I></CENTER><CENTER>Created Feb 25, 1998 by <A HREF="mailto:scullin@netscape.com">WillScullin</A></CENTER><H2>Contents</H2><UL><LI><A HREF="#Introduction">Introduction</A></LI><LI><A HREF="#Basics">The Basics</A></LI><LI><A HREF="#Example">A Simple Example</A></LI><LI><A HREF="#DLL">Moving to a Dynamically Loaded Library</A></LI><LI><A HREF="#Applied">Applied Modularity</A></LI><LI><A HREF="#RefCount">Reference Counting Basics</A></LI><LI><A HREF="#Aggregation">Aggregation</A></LI><LI><A HREF="#FAQ">(Soon To Be) Frequently Asked Questions</A></LI><LI><A HREF="#Links">Links</A></LI><LI><A HREF="#History">Revision History</A></LI></UL><H2><A NAME="Introduction"></A>Introduction</H2>The purpose of this document is provide all the information you need tocreate a new Mozilla Module or break existing code into a module. The mechanismwe're using is based on the principles laid down by COM, so pretty muchanything you know about COM can be applied here, and any reference on COMcan provide you with more interesting and complex examples than the onesprovided here.<H2><A NAME="Basics"></A>The Basics</H2><H3>Interfaces</H3>The basic building blocks of modules are C++ pure virtual interfaces. Apure virtual interface is simply a class where every method is definedas pure virtual, that is:<P><TT>virtual int foo(int bar) = 0;</TT><P>Pure virtual interfaces provide an easy mechanism for passing functiontables between modules that may reside in separate, possibly dynamicallyloaded, libraries. Each interface is assigned a unique Interface Identifier,or <A HREF="#IDs">IID</A>.<H3>nsISupports</H3>The key interface in our model is the <TT>nsISupports</TT> interface, ourequivalent to COM's <TT>IUnknown</TT> interface. <TT>nsISupports</TT> providestwo key features, interface interrogation and reference counting. Interfaceinterrogation is a simple, uniform mechanism for determining which interfacesa object supports, and for hiding the the mechanics of how the object wasimplemented.<P>Interface interrogation is performed using the <TT>QueryInterface()</TT>method. The caller passes in an ID and a pointer to a address to placethe resulting interface. If the query is successful, <TT>QueryInterface()</TT>will return <TT>NS_OK</TT>. If the object does not support the given interface,it will return <TT>NS_NOINTERFACE</TT>.<P>Reference counting is performed using the <TT>AddRef()</TT> and <TT>Release()</TT>methods. An objects reference count generally starts at zero. <TT>AddRef()</TT>increments that reference count, and <TT>Release()</TT> decrements it.If a call to <TT>Release()</TT> causes the reference count to hit zero,the object will generally free itself. A successful <TT>QueryInterface()</TT>will call <TT>AddRef()</TT> on the requested interface before returning.Both <TT>AddRef()</TT> and <TT>Release()</TT> return the resulting referencecount.<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><TR><TD><TT>/*</TT>&nbsp;<BR><TT>&nbsp;* The nsISupports interface</TT>&nbsp;<BR><TT>&nbsp;*/</TT>&nbsp;<P><TT>class nsISupports {</TT>&nbsp;<BR><TT>public:</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; NS_IMETHOD QueryInterface(const nsIID &amp;aIID,&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult) = 0;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; NS_IMETHOD_(nsrefcnt) AddRef(void) = 0;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; NS_IMETHOD_(nsrefcnt) Release(void) = 0;</TT>&nbsp;<BR><TT>};</TT></TD></TR></TABLE>The <TT>NS_IMETHOD</TT> and <TT>NS_IMETHOD_(<I>type</I>)</TT> macros arebasically shorthand for <TT>virtual nsresult</TT> and <TT>virtual <I>type</I></TT>.On Windows they expand to <TT>virtual nsresult __stdcall</TT> and <TT>virtual<I>type</I> __stdcall</TT> for COM compatibility reasons. You don't haveto use them in your interfaces unless you're concerned with COM compatibility.<P>All Mozilla interfaces inherit from <TT>nsISupports</TT>. Inheritingfrom <TT>nsISupports</TT> allows any interface to be interrogated aboutother interfaces that its instance may support, and insures that referencecounting facilities are always available. The IID for <TT>nsISupports</TT>is defined as <TT>NS_ISUPPORTS_IID</TT>.<P><TT>QueryInterface()</TT> has several important characteristics thatmust be maintained. If you perform a <TT>QueryInterface()</TT> on interfaceA and obtain interface B, you must be able to perform a <TT>QueryInterface()</TT>B and obtain interface A. If interfaces A and B are both implemented bythe same instance, performing a <TT>QueryInterface()</TT> for <TT>nsISupports</TT>on either should return the exact same interface. This means that eventhough interface B inherits from nsISupports, performing a QueryInterface()on it may not return the same interface. This important behavior is theonly reliable mechanism for determining whether interfaces A and B areimplemented by the same object.For simple objects, maintaining these behaviorsis easy. Aggregation, as we will see later, can complicate things.<P>On the other hand, objects are allowed a certain degree of flexibilityin their implementations of <TT>AddRef()</TT> and <TT>Release()</TT>. Theycan maintain a single reference count for the entire object, or individualreference counts for each interface. A static object would chose to ignorereference counts altogether. However, a poor implementation of these functionscan have negative results, such as memory leaks or inadvertent access offreed objects.<H3>Factories</H3>Factories are special classes dedicated to creating instances of classes.A Foo class will typically have a FooFactory associated with it. The <TT>nsIFactory</TT>interface is the equivalent of COM's <TT>IClassFactory</TT>.<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><TR><TD><TT>/*</TT>&nbsp;<BR><TT>&nbsp;* The nsIFactory interface</TT>&nbsp;<BR><TT>&nbsp;*/</TT>&nbsp;<P><TT>class nsIFactory: public nsISupports {</TT>&nbsp;<BR><TT>public:</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; NS_IMETHOD CreateInstance(nsISupports *aOuter,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const nsIID &amp;aIID,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult) = 0;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; NS_IMETHOD LockFactory(PRBool aLock) = 0;</TT>&nbsp;<BR><TT>};</TT>&nbsp;<BR>&nbsp;</TD></TR></TABLE>The reason for using factories is that it provides a mechanism for creatingan object without having access to the class declaration for that object.Calling new Foo() requires that at compile time you have access to theclass declaration of Foo(). A factory allows an implementor to hide boththe class declaration and creation details of an object, an extremely importantstep for allowing maximum flexibility in the implementation of a classand reducing compile time dependencies. It can even be used to eliminateall link time dependencies on the class and its factory entirely.<H3>The NSRepository</H3>One of the major goals of our modularization is to remove link time dependencies.So how do you find a module if you've never linked with it? We've createdsomething called the NSRepository. The NSRepository is simply a mappingof class IDs to factories and their containing libraries.<BR>&nbsp;<TABLE COLS=1 WIDTH="99%" BGCOLOR="#CCCCCC" ><TR><TD><TT>class NSRepository {</TT>&nbsp;<BR><TT>public:</TT>&nbsp;<BR><TT>&nbsp; // Finds a factory for a specific class ID</TT>&nbsp;<BR><TT>&nbsp; static nsresult FindFactory(const nsCID &amp;aClass,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsIFactory **aFactory);</TT>&nbsp;<P><TT>&nbsp; // Creates a class instance for a specific class ID</TT>&nbsp;<BR><TT>&nbsp; static nsresult CreateInstance(const nsCID &amp;aClass,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const nsIID &amp;aIID,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsISupports *aDelegate,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult);</TT>&nbsp;<P><TT>&nbsp; // Manually registry a factory for a class</TT>&nbsp;<BR><TT>&nbsp; static nsresult RegisterFactory(const nsCID &amp;aClass,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsIFactory *aFactory,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRBool aReplace);</TT>&nbsp;<P><TT>&nbsp; // Manually registry a dynamically loaded factory for a class</TT>&nbsp;<BR><TT>&nbsp; static nsresult RegisterFactory(const nsCID &amp;aClass,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *aLibrary,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRBool aReplace,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRBool aPersist);</TT>&nbsp;<P><TT>&nbsp; // Manually unregister a factory for a class</TT>&nbsp;<BR><TT>&nbsp; static nsresult UnregisterFactory(const nsCID &amp;aClass,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsIFactory *aFactory);</TT>&nbsp;<BR>&nbsp;<P><TT>&nbsp; // Manually unregister a dynamically loaded factory for aclass</TT>&nbsp;<BR><TT>&nbsp; static nsresult UnregisterFactory(const nsCID &amp;aClass,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *aLibrary);</TT>&nbsp;&nbsp;<P><TT>&nbsp; // Unload dynamically loaded factories that are not in use</TT>&nbsp;<BR><TT>&nbsp; static nsresult FreeLibraries();</TT>&nbsp;<BR><TT>};</TT></TD></TR></TABLE>&nbsp;<BR>There are several ways a factory can make its way into the repository.The most direct is through <TT>RegisterFactory()</TT>. <TT>RegisterFactory()</TT>supports two different registration mechanisms. The first takes a classID and a pointer to a factory. This mechanism can be used on factoriesthat are linked into the executable. The second takes a class ID and thepath to a dynamically loadable library. This mechanism can be used bothinside an executable at run-time and externally using the <TT>aPersist</TT>flag to tell the repository to store the class ID/library relationshipin its permenant store <FONT COLOR="#FF0000">(Only works on Win32 at themoment)</FONT>.<H3><A NAME="IDs"></A>About nsIIDs and nsCIDs</H3>To simplify the process of dynamically finding, loading and binding interfaces,all classes and interfaces are assigned unique IDs. The IDs are unique128 bit numbers that are based on UUIDs. For those who like gory details,their structure is this:<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><TR><TD><TT>struct nsID {</TT>&nbsp;<BR><TT>&nbsp; PRUint32 m0;</TT>&nbsp;<BR><TT>&nbsp; PRUint16 m1, m2;</TT>&nbsp;<BR><TT>&nbsp; PRUint8 m3[8];</TT>&nbsp;<BR><TT>};</TT></TD></TR></TABLE>Frequently you see them represented as strings, like this:<P><TT>{221ffe10-ae3c-11d1-b66c-00805f8a2676}</TT><BR>&nbsp;<BR>To initialize an ID struct you declare them like this:<P><TT>ID = {0x221ffe10, 0xae3c, 0x11d1,</TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0xb6, 0x6c, 0x00, 0x80, 0x5f,0x8a, 0x26, 0x76}};</TT><P>Why the <TT>b66c</TT> couplet gets broken up and grouped with the lastset of bytes is probably a footnote somewhere. On Windows you can use theprograms <TT>uuidgen</TT> and <TT>guidgen</TT>, which ship with VisualC++, to generate IDs.<H2><A NAME="Example"></A>A Simple Example</H2>nsISample.h defines an extremely simple interface and its interface ID(IID). The important things to notice are that the interface inherits fromnsISupports, and all member functions are pure virtual methods.<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><CAPTION><B><TT>File nsISample.h</TT></B></CAPTION><TR><TD><TT>#include "nsISupports.h"</TT>&nbsp;<P><TT>// {57ecad90-ae1a-11d1-b66c-00805f8a2676}</TT>&nbsp;<BR><TT>#define NS_ISAMPLE_IID \</TT>&nbsp;<BR><TT>{0x57ecad90, 0xae1a, 0x11d1, \</TT>&nbsp;<BR><TT>&nbsp; {0xb6, 0x6c, 0x00, 0x80, 0x5f, 0x8a, 0x26, 0x76}}</TT>&nbsp;<P><TT>/*</TT>&nbsp;<BR><TT>&nbsp;* nsISample Interface declaration</TT>&nbsp;<BR><TT>&nbsp;*/</TT>&nbsp;<P><TT>class nsISample: public nsISupports {</TT>&nbsp;<BR><TT>public:</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD Hello() = 0;</TT>&nbsp;<BR><TT>};</TT>&nbsp;<BR>&nbsp;</TD></TR></TABLE>&nbsp;<BR>nsSample.h defines the class ID (CID) for our sample class. Note thatone interface can have a number of classes that implement it, so thereis not necessarily a one-to-one mapping from IIDs to CIDs. It also definesthe function for retrieving our class factory. Notice it does not containa class declaration.<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><CAPTION><B><TT>File nsSample.h</TT></B></CAPTION><TR><TD><TT>#include "nsIFactory.h"</TT>&nbsp;<P><TT>// {d3944dd0-ae1a-11d1-b66c-00805f8a2676}&nbsp;</TT>&nbsp;<BR><TT>#define NS_SAMPLE_CID \</TT>&nbsp;<BR><TT>&nbsp;{0xd3944dd0, 0xae1a, 0x11d1, \</TT>&nbsp;<BR><TT>&nbsp;&nbsp; {0xb6, 0x6c, 0x00, 0x80, 0x5f, 0x8a, 0x26, 0x76}}</TT>&nbsp;<P><TT>extern nsresult GetSampleFactory(nsIFactory **aResult);</TT></TD></TR></TABLE>&nbsp;<BR>nsSample.cpp contains both the declaration and implementation of oursample class, and the declaration and implementation of our class factory.<BR>&nbsp;<TABLE COLS=1 WIDTH="99%" BGCOLOR="#CCCCCC" ><CAPTION><B><TT>File nsSample.cpp</TT></B></CAPTION><TR><TD><TT>#include "nsISample.h"&nbsp;</TT>&nbsp;<BR><TT>#include "nsSample.h"&nbsp;</TT>&nbsp;<P><TT>static NS_DEFINE_IID(kISupportsIID, NS_ISUPPORTS_IID);&nbsp;</TT>&nbsp;<BR><TT>static NS_DEFINE_IID(kIFactoryIID, NS_IFACTORY_IID);&nbsp;</TT>&nbsp;<BR><TT>static NS_DEFINE_IID(kISampleIID, NS_ISAMPLE_IID);&nbsp;</TT>&nbsp;<BR><TT>static NS_DEFINE_CID(kISampleCID, NS_ISAMPLE_CID);&nbsp;</TT>&nbsp;<P><TT><FONT COLOR="#FF0000">/*</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;* nsSampleClass Declaration</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;*/&nbsp;</FONT></TT>&nbsp;<P><TT>class nsSample: public nsISample {&nbsp;</TT>&nbsp;<BR><TT>private:&nbsp;</TT>&nbsp;<BR><TT>&nbsp; nsRefCnt mRefCnt;&nbsp;</TT>&nbsp;<P><TT>public:&nbsp;</TT>&nbsp;<BR><TT>// Constructor and Destuctor&nbsp;</TT>&nbsp;<BR><TT>&nbsp; nsSample();&nbsp;</TT>&nbsp;<BR><TT>&nbsp; ~nsSample();&nbsp;</TT>&nbsp;<P><TT>// nsISupports methods&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD QueryInterface(const nsIID &amp;aIID,&nbsp;&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult);&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD_(nsrefcnt) AddRef(void);&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD_(nsrefcnt) Release(void);&nbsp;</TT>&nbsp;<P><TT>// nsISample method&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD Hello();&nbsp;</TT>&nbsp;<BR><TT>};&nbsp;</TT>&nbsp;<P><TT><FONT COLOR="#FF0000">/*&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;* nsSampleFactory Declaration&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;*/&nbsp;</FONT></TT>&nbsp;<P><TT>class nsSampleFactory: public nsIFactory {&nbsp;</TT>&nbsp;<BR><TT>private:&nbsp;</TT>&nbsp;<BR><TT>&nbsp; nsRefCnt mRefCnt;&nbsp;</TT>&nbsp;<P><TT>public:&nbsp;</TT>&nbsp;<BR><TT>&nbsp; nsSampleFactory();&nbsp;</TT>&nbsp;<BR><TT>&nbsp; ~nsSampleFactory();&nbsp;</TT>&nbsp;<P><TT>// nsISupports methods&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD QueryInterface(const nsIID &amp;aIID,&nbsp;&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult);&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD_(nsrefcnt) AddRef(void);&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD_(nsrefcnt) Release(void);&nbsp;</TT>&nbsp;<P><TT>// nsIFactory methods&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD CreateInstance(nsISupports *aOuter,&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const nsIID &amp;aIID,&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult);&nbsp;</TT>&nbsp;<P><TT>&nbsp; NS_IMETHOD_(void) LockFactory(PRBool aLock);&nbsp;</TT>&nbsp;<BR><TT>};&nbsp;</TT>&nbsp;<P><TT><FONT COLOR="#FF0000">/*&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;* nsSample Implementation&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;*/&nbsp;</FONT></TT>&nbsp;<P><TT>nsSample::nsSample()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; mRefCnt = 0;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsSample::~nsSample()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; assert(mRefCnt == 0);&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsresult nsSample::QueryInterface(const nsIID &amp;aIID,&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult)&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (aResult == NULL) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NULL_POINTER;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; // Always NULL result, in case of failure&nbsp;</TT>&nbsp;<BR><TT>&nbsp; *aResult = NULL;&nbsp;</TT>&nbsp;<P><TT>&nbsp; if (aIID.Equals(kISupportsIID)) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; *aResult = (void *) this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; } else if (aIID.Equals(kISampleIID)) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; *aResult = (void *) this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; if (aResult != NULL) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NO_INTERFACE;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; AddRef();&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return NS_OK;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsRefCount nsSample::AddRef()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return ++mRefCnt;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsRefCount nsSample::Release()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (--mRefCnt == 0) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; delete this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return 0; // Don't access mRefCnt after deleting!&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return mRefCnt;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT><FONT COLOR="#FF0000">/*&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;* nsSampleFactory Implementation&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;*/&nbsp;</FONT></TT>&nbsp;<P><TT>nsSampleFactory::nsSampleFactory()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; mRefCnt = 0;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsSampleFactory::~nsSampleFactory()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; assert(mRefCnt == 0);&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsresult nsSampleFactory::QueryInterface(const nsIID &amp;aIID,&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult)&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (aResult == NULL) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NULL_POINTER;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; // Always NULL result, in case of failure&nbsp;</TT>&nbsp;<BR><TT>&nbsp; *aResult = NULL;&nbsp;</TT>&nbsp;<P><TT>&nbsp; if (aIID.Equals(kISupportsIID)) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; *aResult = (void *) this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; } else if (aIID.Equals(kIFactoryIID)) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; *aResult = (void *) this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; if (*aResult == NULL) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NO_INTERFACE;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; AddRef(); // Increase reference count for caller&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return NS_OK;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsRefCount nsSampleFactory::AddRef()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return ++mRefCnt;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsRefCount nsSampleFactory::Release()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (--mRefCnt == 0) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; delete this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return 0; // Don't access mRefCnt after deleting!&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return mRefCnt;&nbsp;</TT>&nbsp;<BR><TT>}</TT>&nbsp;<P><TT>nsresult nsSampleFactory::CreateInstance(nsISupports *aOuter,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const nsIID &amp;aIID,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult)</TT>&nbsp;<BR><TT>{</TT>&nbsp;<BR><TT>&nbsp; if (aResult == NULL) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NULL_POINTER;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; *aResult = NULL;</TT>&nbsp;<P><TT>&nbsp; nsISupports inst = new nsSample();</TT>&nbsp;<P><TT>&nbsp; if (inst == NULL) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_OUT_OF_MEMORY;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; nsresult res = inst->QueryInterface(aIID, aResult);</TT>&nbsp;<P><TT>&nbsp; if (res != NS_OK) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; // We didn't get the right interface, so cleanup</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; delete inst;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; return res;</TT>&nbsp;<BR><TT>}</TT>&nbsp;<P><TT>void nsSampleFactory::LockFactory(PRBool aLock)</TT>&nbsp;<BR><TT>{</TT>&nbsp;<BR><TT>&nbsp; // Not implemented in simplest case.</TT>&nbsp;<BR><TT>}</TT>&nbsp;<P><TT>nsresult GetSampleFactory(nsIFactory **aResult)&nbsp;</TT>&nbsp;<BR><TT>{</TT>&nbsp;<BR><TT>&nbsp; if (aResult == NULL) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NULL_POINTER;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; *aResult = NULL;</TT>&nbsp;<P><TT>&nbsp; nsISupports inst = new nsSampleFactory();</TT>&nbsp;<P><TT>&nbsp; if (inst == NULL) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_OUT_OF_MEMORY;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; nsresult res = inst->QueryInterface(kIFactoryIID, aResult);</TT>&nbsp;<P><TT>&nbsp; if (res != NS_OK) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; // We didn't get the right interface, so cleanup</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; delete inst;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; return res;</TT>&nbsp;<BR><TT>}</TT></TD></TR></TABLE>&nbsp;<BR>main.cpp is a simple program that creates an instance of our sampleclass and disposes of it. Because it obtains the class factory directly,it doesn't use the CID for class.<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><CAPTION><B><TT>File main.cpp</TT></B></CAPTION><TR><TD><TT>#include "nsISample.h"</TT>&nbsp;<BR><TT>#include "nsSample.h"</TT>&nbsp;<P><TT>static NS_DEFINE_IID(kISampleIID, NS_ISAMPLE_IID);</TT>&nbsp;<P><TT>int main(int argc, char *argv[])</TT>&nbsp;<BR><TT>{</TT>&nbsp;<BR><TT>&nbsp; nsIFactory *factory;</TT>&nbsp;<BR><TT>&nbsp; GetSampleFactory(&amp;factory);</TT>&nbsp;<P><TT>&nbsp; nsISample *sample;</TT>&nbsp;<P><TT>&nbsp; nsresult res = factory->CreateInstance(NULL, kISampleIID,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void **) &amp;sample);</TT>&nbsp;<BR><TT>&nbsp;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (res == NS_OK) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; sample->Hello();</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; sample->Release();</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; return 0;</TT>&nbsp;<BR><TT>}</TT></TD></TR></TABLE><H2><A NAME="DLL"></A>Moving to a Dynamically Linked Library</H2><H3>Implementing a DLL</H3>Once you've set a factory, moving it to a DLL is a relatively trivial thing.A DLL that contains a factory need to define one or two exported functions:<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><TR><TD><TT>// Returns the factory associated with the given class ID</TT>&nbsp;<BR><TT>extern "C" NS_EXPORT nsresult NSGetFactory(const nsCID &amp;aCID,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsIFactory **aFactory);</TT>&nbsp;<P><TT>// Returns whether the DLL can be unloaded now.</TT>&nbsp;<BR><TT>extern "C" NS_EXPORT PRBool NSCanUnload();</TT></TD></TR></TABLE>The implementation of <TT>NSGetFactory()</TT> in the simplest case is nearlyidentical to that of <TT>GetSampleFactory()</TT> in our previous example.You only need to verify that the class ID passed in is the correct onefor the factory you implement. If your DLL contains multiple factories,you'll need to add conditional code to determine which one to return.<P><TT>NSCanUnload()</TT> is an optional, but useful function. If implemented,it allows the NSRepository to free up memory by unloading DLLs it is nolonger using when <TT>FreeLibraries()</TT> is called. The implementationtakes into consideration two things when deciding whether or not a DLLcan be unloaded: Whether any of its factories are currently in use, andwhether anyone has locked the server. If <TT>NSCanUnload()</TT> is notimplemented, the DLL will not be unloaded.<BR>&nbsp;<BR>The following example turns <TT>nsSample.cpp</TT>into a file that can be compiled into a DLL. The differences are highlightedin <FONT COLOR="#3333FF">blue</FONT>. There really aren't that many.<BR>&nbsp;<TABLE COLS=1 WIDTH="99%" BGCOLOR="#CCCCCC" ><CAPTION><B><TT>File nsSample3.cpp</TT></B></CAPTION><TR><TD><TT>#include &lt;iostream.h></TT>&nbsp;<BR><TT>#include "pratom.h"</TT>&nbsp;<BR><TT>#include "nsRepository.h"</TT>&nbsp;<BR><TT>#include "nsISample.h"&nbsp;</TT>&nbsp;<BR><TT>#include "nsSample.h"&nbsp;</TT>&nbsp;<P><TT>static NS_DEFINE_IID(kISupportsIID, NS_ISUPPORTS_IID);&nbsp;</TT>&nbsp;<BR><TT>static NS_DEFINE_IID(kIFactoryIID, NS_IFACTORY_IID);&nbsp;</TT>&nbsp;<BR><TT>static NS_DEFINE_IID(kISampleIID, NS_ISAMPLE_IID);&nbsp;</TT>&nbsp;<BR><TT>static NS_DEFINE_CID(kSampleCID, NS_SAMPLE_CID);&nbsp;</TT>&nbsp;<P><TT><FONT COLOR="#3333FF">/*</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp;* Globals</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp;*/</FONT></TT>&nbsp;<P><TT><FONT COLOR="#3333FF">static PRInt32 gLockCnt = 0;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">static PRInt32 gFactoryCnt = 0;</FONT></TT>&nbsp;<P><TT><FONT COLOR="#FF0000">/*</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;* nsSampleClass Declaration</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;*/&nbsp;</FONT></TT>&nbsp;<P><TT>class nsSample: public nsISample {&nbsp;</TT>&nbsp;<BR><TT>private:&nbsp;</TT>&nbsp;<BR><TT>&nbsp; nsrefcnt mRefCnt;&nbsp;</TT>&nbsp;<P><TT>public:&nbsp;</TT>&nbsp;<BR><TT>// Constructor and Destuctor&nbsp;</TT>&nbsp;<BR><TT>&nbsp; nsSample();&nbsp;</TT>&nbsp;<BR><TT>&nbsp; ~nsSample();&nbsp;</TT>&nbsp;<P><TT>// nsISupports methods&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD QueryInterface(const nsIID &amp;aIID,&nbsp;&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult);&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD_(nsrefcnt) AddRef(void);&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD_(nsrefcnt) Release(void);&nbsp;</TT>&nbsp;<P><TT>// nsISample method&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD Hello();&nbsp;</TT>&nbsp;<BR><TT>};&nbsp;</TT>&nbsp;<P><TT><FONT COLOR="#FF0000">/*&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;* nsSampleFactory Declaration&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;*/&nbsp;</FONT></TT>&nbsp;<P><TT>class nsSampleFactory: public nsIFactory {&nbsp;</TT>&nbsp;<BR><TT>private:&nbsp;</TT>&nbsp;<BR><TT>&nbsp; nsrefcnt mRefCnt;&nbsp;</TT>&nbsp;<P><TT>public:&nbsp;</TT>&nbsp;<BR><TT>&nbsp; nsSampleFactory();&nbsp;</TT>&nbsp;<BR><TT>&nbsp; ~nsSampleFactory();&nbsp;</TT>&nbsp;<P><TT>// nsISupports methods&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD QueryInterface(const nsIID &amp;aIID,&nbsp;&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult);&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD_(nsrefcnt) AddRef(void);&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD_(nsrefcnt) Release(void);&nbsp;</TT>&nbsp;<P><TT>// nsIFactory methods&nbsp;</TT>&nbsp;<BR><TT>&nbsp; NS_IMETHOD CreateInstance(nsISupports *aOuter,&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const nsIID &amp;aIID,&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult);&nbsp;</TT>&nbsp;<P><TT>&nbsp; NS_IMETHOD_(void) LockFactory(PRBool aLock);&nbsp;</TT>&nbsp;<BR><TT>};&nbsp;</TT>&nbsp;<P><TT><FONT COLOR="#FF0000">/*&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;* nsSample Implemtation&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;*/&nbsp;</FONT></TT>&nbsp;<P><TT>nsSample::nsSample()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; mRefCnt = 0;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsSample::~nsSample()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>// assert(mRefCnt == 0);&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsresult nsSample::Hello() {</TT>&nbsp;<BR><TT>&nbsp; cout &lt;&lt; "Hello, world\n";</TT>&nbsp;<P><TT>&nbsp; return NS_OK;</TT>&nbsp;<BR><TT>}</TT>&nbsp;<P><TT>nsresult nsSample::QueryInterface(const nsIID &amp;aIID,&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult)&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (aResult == NULL) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NULL_POINTER;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; // Always NULL result, in case of failure&nbsp;</TT>&nbsp;<BR><TT>&nbsp; *aResult = NULL;&nbsp;</TT>&nbsp;<P><TT>&nbsp; if (aIID.Equals(kISupportsIID)) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; *aResult = (void *) this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; } else if (aIID.Equals(kISampleIID)) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; *aResult = (void *) this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; if (aResult != NULL) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_NOINTERFACE;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; AddRef();&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return NS_OK;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsrefcnt nsSample::AddRef()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return ++mRefCnt;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsrefcnt nsSample::Release()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (--mRefCnt == 0) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; delete this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return 0; // Don't access mRefCnt after deleting!&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return mRefCnt;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT><FONT COLOR="#FF0000">/*&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;* nsSampleFactory Implementation&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#FF0000">&nbsp;*/</FONT>&nbsp;</TT>&nbsp;<P><TT>nsSampleFactory::nsSampleFactory()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; mRefCnt = 0;&nbsp;</TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp; PR_AtomicIncrement(&amp;gFactoryCnt);</FONT></TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsSampleFactory::~nsSampleFactory()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>// assert(mRefCnt == 0);&nbsp;</TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp; PR_AtomicDecrement(&amp;gFactoryCnt);</FONT></TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsresult nsSampleFactory::QueryInterface(const nsIID &amp;aIID,&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult)&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (aResult == NULL) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NULL_POINTER;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; // Always NULL result, in case of failure&nbsp;</TT>&nbsp;<BR><TT>&nbsp; *aResult = NULL;&nbsp;</TT>&nbsp;<P><TT>&nbsp; if (aIID.Equals(kISupportsIID)) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; *aResult = (void *) this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; } else if (aIID.Equals(kIFactoryIID)) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; *aResult = (void *) this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; if (*aResult == NULL) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_NOINTERFACE;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<P><TT>&nbsp; AddRef(); // Increase reference count for caller&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return NS_OK;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsrefcnt nsSampleFactory::AddRef()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return ++mRefCnt;&nbsp;</TT>&nbsp;<BR><TT>}&nbsp;</TT>&nbsp;<P><TT>nsrefcnt nsSampleFactory::Release()&nbsp;</TT>&nbsp;<BR><TT>{&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (--mRefCnt == 0) {&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; delete this;&nbsp;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return 0; // Don't access mRefCnt after deleting!&nbsp;</TT>&nbsp;<BR><TT>&nbsp; }&nbsp;</TT>&nbsp;<BR><TT>&nbsp; return mRefCnt;&nbsp;</TT>&nbsp;<BR><TT>}</TT>&nbsp;<P><TT>nsresult nsSampleFactory::CreateInstance(nsISupports *aOuter,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const nsIID &amp;aIID,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **aResult)</TT>&nbsp;<BR><TT>{</TT>&nbsp;<BR><TT>&nbsp; if (aResult == NULL) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NULL_POINTER;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; *aResult = NULL;</TT>&nbsp;<P><TT>&nbsp; nsISupports *inst = new nsSample();</TT>&nbsp;<P><TT>&nbsp; if (inst == NULL) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_OUT_OF_MEMORY;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; nsresult res = inst->QueryInterface(aIID, aResult);</TT>&nbsp;<P><TT>&nbsp; if (res != NS_OK) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; // We didn't get the right interface, so cleanup</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; delete inst;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; return res;</TT>&nbsp;<BR><TT>}</TT>&nbsp;<P><TT><FONT COLOR="#3333FF">/*</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp;* Exported functions</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp;*/</FONT></TT>&nbsp;<P><TT><FONT COLOR="#3333FF">void nsSampleFactory::LockFactory(PRBool aLock)</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">{</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp; if (aLock) {</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp;&nbsp;&nbsp; PR_AtomicIncrement(&amp;gLockCnt);</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp; } else {</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp;&nbsp;&nbsp; PR_AtomicDecrement(&amp;gLockCnt);</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp; }</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">}</FONT></TT>&nbsp;<P><TT><FONT COLOR="#3333FF">extern "C" NS_EXPORT nsresult NSGetFactory(constnsCID &amp;aCID,&nbsp;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsIFactory **aResult)&nbsp;</FONT></TT>&nbsp;<BR><TT>{</TT>&nbsp;<BR><TT>&nbsp; if (aResult == NULL) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NULL_POINTER;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; *aResult = NULL;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; nsISupports *inst;</TT>&nbsp;<P><TT><FONT COLOR="#3333FF">&nbsp; if (aCID.Equals(kSampleCID)) {</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp;&nbsp;&nbsp; inst = new nsSampleFactory();</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp; } else {</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp;&nbsp;&nbsp; return NS_ERROR_ILLEGAL_VALUE;</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp; }</FONT></TT>&nbsp;<P><TT>&nbsp; if (inst == NULL) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_OUT_OF_MEMORY;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; nsresult res = inst->QueryInterface(kIFactoryIID, (void **)aResult);</TT>&nbsp;<P><TT>&nbsp; if (res != NS_OK) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; // We didn't get the right interface, so cleanup</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; delete inst;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; return res;</TT>&nbsp;<BR><TT>}</TT>&nbsp;<P><TT><FONT COLOR="#3333FF">extern "C" NS_EXPORT PRBool NSCanUnload()</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">{</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">&nbsp; return PRBool(gFactoryCnt == 0 &amp;&amp;gLockCnt == 0);</FONT></TT>&nbsp;<BR><TT><FONT COLOR="#3333FF">}</FONT></TT></TD></TR></TABLE>Now, instead of directly calling the factory, we call <TT>NSRepository::CreateInstance()</TT>.We rely on the factory registering itself somehow.<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><CAPTION><B><TT>File: main2.cpp</TT></B></CAPTION><TR><TD><TT>#include "nsRepository.h"</TT>&nbsp;<BR><TT>#include "nsISample.h"</TT>&nbsp;<BR><TT>#include "nsSample.h"</TT>&nbsp;<P><TT>static NS_DEFINE_IID(kISampleIID, NS_ISAMPLE_IID);</TT>&nbsp;<BR><TT>static NS_DEFINE_CID(kSampleCID, NS_SAMPLE_CID);</TT>&nbsp;<P><TT>int main(int argc, char *argv[])</TT>&nbsp;<BR><TT>{</TT>&nbsp;<BR><TT>&nbsp; nsISample *sample;</TT>&nbsp;<P><TT>&nbsp; nsresult res = NSRepository::CreateInstance(kSampleCID,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kISampleIID,</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void **) &amp;sample);</TT>&nbsp;<BR><TT>&nbsp;&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (res == NS_OK) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; sample->Hello();</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; sample->Release();</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; return 0;</TT>&nbsp;<BR><TT>}</TT></TD></TR></TABLE><H3>Registering a DLL</H3>This is currently being hashed out. You can currently manually registera DLL using the NSRepository's <TT>RegisterFactory()</TT> method (For anexample of this, see <TT>nsSample2.cpp</TT>).A persistent, external registry is being hashed out for platforms otherthan Windows. On Windows, we will use the Windows Registry.<BR>&nbsp;<BR>A DLL can export two additional functions for self registration andunregistration.<BR>&nbsp;<TABLE WIDTH="100%" BGCOLOR="#CCCCCC" ><TR><TD><TT>extern "C" NS_EXPORT nsresult NSRegisterSelf(const char *path);</TT>&nbsp;<BR><TT>extern "C" NS_EXPORT nsresult NSUnregisterSelf(const char *path);</TT></TD></TR></TABLE>This allows a DLL to register and unregister all its factories. On Windows,a simple program RegFactory.exe can be used to register self-registeringDLLs. Other platforms are pending.<H2><A NAME="Applied"></A>Applied Modularity</H2>It can be seen that creating new modules is relatively simple. However,much of what we're trying to accomplish is turning existing code into modules.The process for doing this is not nearly as clear cut.<P>For any give chunk of code, cohesive or not, there are functions itprovides to the outside world, and functions it requires from the outsideworld. In an extremely simplistic approach, these can be looked at as twointerfaces. Part of the new module's interface will be an Init() method,through which the outside world can pass the interface containing the requiredsupport functions. This an inelegant, but wholly viable short term solution.<P>Initially many of the interfaces provided to new modules will be adhoc, and there is likely to be redundancy. This is going to be an evolutionaryprocess, not a revolutionary one. The ad hoc interfaces will be phasedout as cleaner, well though out interfaces are introduced.<P>A concrete example should go here.<H2><A NAME="RefCount"></A>Reference Counting Basics</H2>Reference counting is a critical part of modularity picture. There area number of basic reference counting rules to remember. Here's a quicksummary.<H3>Out Parameters</H3>Functions that return a new interface should call AddRef() on that interfacebefore returning it.<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><TR><TD><TT>IFoo *GetFoo()</TT>&nbsp;<BR><TT>{</TT>&nbsp;<BR><TT>&nbsp; IFoo *res = mFoo;</TT>&nbsp;<BR><TT>&nbsp; res->AddRef();</TT>&nbsp;<BR><TT>&nbsp; return res;</TT>&nbsp;<BR><TT>}</TT></TD></TR></TABLE>or<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><TR><TD><TT>nsresult GetFoo(IFoo **aFooRes)</TT>&nbsp;<BR><TT>{</TT>&nbsp;<BR><TT>&nbsp; if (aFooRes == NULL) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NULL_POINTER;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<BR><TT>&nbsp; *aFooRes = mFoo;</TT>&nbsp;<BR><TT>&nbsp; (*aFooRes)->AddRef();</TT>&nbsp;<P><TT>&nbsp; return NS_OK;</TT>&nbsp;<BR><TT>}</TT></TD></TR></TABLE>Remember that this applies to the interfaces returned by <TT>QueryInterface()</TT>,<TT>CreateInstance()</TT> and <TT>NS_New<I>X</I>()</TT>, and you must call<TT>Release()</TT> on them when you are done to avoid memory leaks.<H3>In Parameters and Local Pointers</H3>Interfaces that are passed in to a function and local copies of that interfacepointer are assumed to be in the lifetime of the calling function, anddo not need to have <TT>AddRef()</TT> called.<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><TR><TD><TT>nsresult TweekFoo(IFoo *aFoo1, IFoo *aFoo2) {</TT>&nbsp;<BR><TT>&nbsp; IFoo local = aFoo;</TT>&nbsp;<BR><TT>&nbsp;</TT>&nbsp;<BR><TT>&nbsp; if (aFoo->Bar() == NS_OK) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; local = aFoo2;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<P><TT>&nbsp; return local->Boff();</TT>&nbsp;<BR><TT>}</TT></TD></TR></TABLE><H3>In-Out Parameters</H3>In-Out parameters are used as both In parameters and Out parameters. Ifa function changes the value of an interface In-Out parameter, it shouldcall <TT>Release()</TT> on the interface passed in and <TT>AddRef()</TT>on the interface passed out.<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><TR><TD><TT>nsresult RefreshFoo(IFoo **aFoo)</TT>&nbsp;<BR><TT>{</TT>&nbsp;<BR><TT>&nbsp; if (aFoo == NULL || *aFoo == NULL) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; return NS_ERROR_NULL_PARAMETER;</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<BR><TT>&nbsp; if ((*aFoo)->Stale()) {</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; (*aFoo)->Release();</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; *aFoo = mFoo;</TT>&nbsp;<BR><TT>&nbsp;&nbsp;&nbsp; (*aFoo)->AddRef();</TT>&nbsp;<BR><TT>&nbsp; }</TT>&nbsp;<BR><TT>&nbsp; return NS_OK;</TT>&nbsp;<BR><TT>}</TT></TD></TR></TABLE><H3>Global and Member Variables</H3>Both global and member variables have lifetimes that can be changed byany number of functions. Therefore one should call <TT>AddRef()</TT> onany global or member variable that is being passed to a function, and call<TT>Release()</TT> afterward.<BR>&nbsp;<TABLE COLS=1 WIDTH="100%" BGCOLOR="#CCCCCC" ><TR><TD><TT>mFoo->AddRef();</TT>&nbsp;<BR><TT>TweekFoo(mFoo);</TT>&nbsp;<BR><TT>mFoo->Release();</TT></TD></TR></TABLE>&nbsp;<H2><A NAME="Aggregation"></A>Aggregation</H2>A description of how to do basic aggregation.<H2><A NAME="FAQ"></A>(Soon to be) Frequently Asked Questions</H2><H3>Why are we mimicking COM? Doesn't COM suck?</H3>You're probably basing this opinion on your experiences with or storiesyou've heard about OLE. A really important thing to remember is that COMis not OLE. OLE was built one top of COM, but it's not a shining exampleof COM. COM is simply a mechanism for laying out and using interfaces,the important components we've pretty much described here. OLE (actuallyOLE 2) was one of the first efforts to use COM.<H3>Why C++?</H3>C++ provides the easiest mechanism for implementing interfaces. You canmanually assemble interfaces using function tables and macros, but you'dbe simply doing by hand what a C++ compiler can do for you automatically.<H3>Can I use C?</H3>You can use C everywhere except your interface. There are mechanisms fordeclaring interfaces in C, but they're pretty gruesome and compiler dependent,and we're trying to make this as light weight as possible.<H3>Why not COM?</H3>The only platform for which COM support is currently widely available isWindows. Microsoft ships a COM extension for the Macintosh, but it's generallyonly installed with Internet Explorer or Microsoft Office. UNIX supportfor COM is scarce.<H3>Why not COM on Windows?</H3>Because it's not a cross platform solution, and that's what we need. We'regoing to make every effort to make our interfaces compatible with COM onplatforms that support it, so it may not matter. But no promises, yet.<H3>What are the major differences?</H3>COM actually prescribes a language independent mechanism for laying outfunction pointer tables, and call stack conventions. We've focused on C++because most of our code is written in C or C++, and we're currently notconcerned, for the sake of simplicity, with supporting other languages.A COM compliant C++ compiler does most of the right things automaticallywhen dealing with pure virtual interfaces (except the COM function callstack conventions, which are typically referred to as "Pascal" conventionsand require special function declarations).<P>Microsoft provides an extensive support infrastructure for COM. Thistechnology is built into Windows, but not most other platforms. The technologycan be licensed from Microsoft, but for obvious reasons we are not goingto be doing that. In house equivalents to the important elements of thistechnology will be developed as needed.<H2><A NAME="Links"></A>Links</H2><UL><LI>&nbsp;<A HREF="http://www.microsoft.com/oledev/olecom/title.htm">The ComponentObject Model Specification</A></LI></UL><H2><A NAME="History"></A>Revision History</H2><UL><LI>Feb 25, 1998, Created</LI></UL><HR WIDTH="100%"><FONT SIZE="-1"><CENTER>Copyright &copy; 1998<A HREF="http://home.netscape.com/misc/contact_info.html">NetscapeCommunications Corporation</A></CENTER></FONT></BODY></HTML>